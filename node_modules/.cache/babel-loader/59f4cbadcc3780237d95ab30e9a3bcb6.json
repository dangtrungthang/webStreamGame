{"ast":null,"code":"\"use strict\";\n/**\r\n * FocusManager.ts\r\n *\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n *\r\n * Manages focusable elements for better keyboard navigation (web version)\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyFocusableComponentMixin = exports.FocusManager = void 0;\n\nvar ReactDOM = require(\"react-dom\");\n\nvar AutoFocusHelper_1 = require(\"../../common/utils/AutoFocusHelper\");\n\nvar FocusManager_1 = require(\"../../common/utils/FocusManager\");\n\nvar Timers_1 = require(\"../../common/utils/Timers\");\n\nvar UserInterface_1 = require(\"../UserInterface\");\n\nvar ATTR_NAME_TAB_INDEX = 'tabindex';\nvar ATTR_NAME_ARIA_HIDDEN = 'aria-hidden';\n\nvar _isShiftPressed;\n\nvar FocusManager =\n/** @class */\nfunction (_super) {\n  __extends(FocusManager, _super);\n\n  function FocusManager(parent) {\n    return _super.call(this, parent) || this;\n  } // Not really public\n\n\n  FocusManager.initListeners = function () {\n    // The default behaviour on Electron is to release the focus after the\n    // Tab key is pressed on a last focusable element in the page and focus\n    // the first focusable element on a consecutive Tab key press.\n    // We want to avoid losing this first Tab key press.\n    var _checkFocusTimer; // Checking if Shift is pressed to move the focus into the right direction.\n\n\n    window.addEventListener('keydown', function (event) {\n      _isShiftPressed = event.shiftKey;\n    });\n    window.addEventListener('keyup', function (event) {\n      _isShiftPressed = event.shiftKey;\n    });\n    document.body.addEventListener('focusout', function (event) {\n      if (!UserInterface_1.default.isNavigatingWithKeyboard() || event.target === document.body) {\n        return;\n      }\n\n      if (_checkFocusTimer) {\n        Timers_1.default.clearTimeout(_checkFocusTimer);\n      }\n\n      if (FocusManager._skipFocusCheck) {\n        // When in between the FocusManager restrictions,\n        // don't check for the focus change here, FocusManager\n        // will take care of it.\n        FocusManager._skipFocusCheck = false;\n        return;\n      }\n\n      _checkFocusTimer = Timers_1.default.setTimeout(function () {\n        _checkFocusTimer = undefined;\n\n        if (UserInterface_1.default.isNavigatingWithKeyboard() && (!FocusManager._currentFocusedComponent || !FocusManager._currentFocusedComponent.removed) && (!document.activeElement || document.activeElement === document.body)) {\n          // This should work for Electron and the browser should\n          // send the focus to the address bar anyway.\n          FocusManager.focusFirst(_isShiftPressed);\n        }\n      }, 100);\n    });\n  };\n\n  FocusManager.prototype.addFocusListenerOnComponent = function (component, onFocus) {\n    try {\n      var el = ReactDOM.findDOMNode(component);\n\n      if (el) {\n        el.addEventListener('focus', onFocus);\n      }\n    } catch (_a) {// Swallow exception due to component unmount race condition.\n    }\n  };\n\n  FocusManager.prototype.removeFocusListenerFromComponent = function (component, onFocus) {\n    try {\n      var el = ReactDOM.findDOMNode(component);\n\n      if (el) {\n        el.removeEventListener('focus', onFocus);\n      }\n    } catch (_a) {// Swallow exception due to component unmount race condition.\n    }\n  };\n\n  FocusManager.prototype.focusComponent = function (component) {\n    try {\n      var el = ReactDOM.findDOMNode(component);\n\n      if (el && el.focus) {\n        FocusManager.setLastFocusedProgrammatically(el);\n        el.focus();\n        return true;\n      }\n    } catch (_a) {// Swallow exception due to component unmount race condition.\n    }\n\n    return false;\n  };\n\n  FocusManager.setLastFocusedProgrammatically = function (element) {\n    this._lastFocusedProgrammatically = element;\n  };\n\n  FocusManager.getLastFocusedProgrammatically = function (reset) {\n    var ret = FocusManager._lastFocusedProgrammatically;\n\n    if (ret && reset) {\n      FocusManager._lastFocusedProgrammatically = undefined;\n    }\n\n    return ret;\n  };\n\n  FocusManager._isComponentAvailable = function (storedComponent) {\n    return !storedComponent.accessibleOnly && !storedComponent.removed && !storedComponent.restricted && storedComponent.limitedCount === 0 && storedComponent.limitedCountAccessible === 0;\n  };\n\n  FocusManager._getFirstFocusable = function (last, parent) {\n    var focusable = Object.keys(FocusManager._allFocusableComponents).filter(function (componentId) {\n      return !parent || componentId in parent._myFocusableComponentIds;\n    }).map(function (componentId) {\n      return FocusManager._allFocusableComponents[componentId];\n    }).filter(FocusManager._isComponentAvailable).map(function (storedComponent) {\n      return {\n        storedComponent: storedComponent,\n        el: ReactDOM.findDOMNode(storedComponent.component)\n      };\n    }).filter(function (f) {\n      return f.el && f.el.focus && (f.el.tabIndex || 0) >= 0 && !f.el.disabled;\n    });\n\n    if (focusable.length) {\n      focusable.sort(function (a, b) {\n        // Some element which is mounted later could come earlier in the DOM,\n        // so, we sort the elements by their appearance in the DOM.\n        if (a === b) {\n          return 0;\n        }\n\n        return a.el.compareDocumentPosition(b.el) & document.DOCUMENT_POSITION_PRECEDING ? 1 : -1;\n      });\n      return focusable[last ? focusable.length - 1 : 0];\n    }\n\n    return undefined;\n  };\n\n  FocusManager.focusFirst = function (last) {\n    var first = FocusManager._getFirstFocusable(last);\n\n    if (first) {\n      var storedComponent_1 = first.storedComponent;\n      AutoFocusHelper_1.FocusArbitratorProvider.requestFocus(storedComponent_1.component, function () {\n        FocusManager.setLastFocusedProgrammatically(first.el);\n        first.el.focus();\n      }, function () {\n        return FocusManager._isComponentAvailable(storedComponent_1);\n      }, AutoFocusHelper_1.FocusCandidateType.FocusFirst);\n    }\n  };\n\n  FocusManager.prototype.resetFocus = function (focusFirstWhenNavigatingWithKeyboard) {\n    if (FocusManager._resetFocusTimer) {\n      Timers_1.default.clearTimeout(FocusManager._resetFocusTimer);\n      FocusManager._resetFocusTimer = undefined;\n    }\n\n    if (UserInterface_1.default.isNavigatingWithKeyboard() && focusFirstWhenNavigatingWithKeyboard) {\n      // When we're in the keyboard navigation mode, we want to have the\n      // first focusable component to be focused straight away, without the\n      // necessity to press Tab.\n      var first_1 = FocusManager._getFirstFocusable(false, FocusManager._currentRestrictionOwner);\n\n      if (first_1) {\n        var storedComponent_2 = first_1.storedComponent;\n        AutoFocusHelper_1.FocusArbitratorProvider.requestFocus(storedComponent_2.component, function () {\n          FocusManager.setLastFocusedProgrammatically(first_1.el);\n          first_1.el.focus();\n        }, function () {\n          return FocusManager._isComponentAvailable(storedComponent_2);\n        }, AutoFocusHelper_1.FocusCandidateType.FocusFirst);\n      }\n    } else if (typeof document !== 'undefined' && document.body && document.body.focus && document.body.blur) {\n      // An example to explain this part:\n      // We've shown a modal dialog which is higher in the DOM by clicking\n      // on a button which is lower in the DOM, we've applied the restrictions\n      // and only the elements from the modal dialog are focusable now.\n      // But internally the browser keeps the last focus position in the DOM\n      // (even if we do blur() for the button) and when Tab is pressed again,\n      // the browser will start searching for the next focusable element from\n      // this position.\n      // This means that the first Tab press will get us to the browser's address\n      // bar (or nowhere in case of Electron) and only the second Tab press will\n      // lead us to focusing the first focusable element in the modal dialog.\n      // In order to avoid losing this first Tab press, we're making <body>\n      // focusable, focusing it, removing the focus and making it unfocusable\n      // back again.\n      // Defer the work to avoid triggering sync layout.\n      FocusManager._resetFocusTimer = Timers_1.default.setTimeout(function () {\n        FocusManager._resetFocusTimer = undefined;\n        var currentFocused = FocusManager._currentFocusedComponent;\n\n        if (currentFocused && !currentFocused.removed && !currentFocused.restricted) {\n          // No need to reset the focus because it's moved inside the restricted area\n          // already (manually or with autofocus).\n          return;\n        }\n\n        var prevTabIndex = FocusManager._setTabIndex(document.body, -1);\n\n        FocusManager.setLastFocusedProgrammatically(document.body);\n        document.body.focus();\n        document.body.blur();\n\n        FocusManager._setTabIndex(document.body, prevTabIndex);\n      }, 100);\n    }\n  };\n\n  FocusManager.prototype._updateComponentFocusRestriction = function (storedComponent) {\n    var newAriaHidden = storedComponent.restricted || storedComponent.limitedCount > 0 ? true : undefined;\n    var newTabIndex = newAriaHidden || storedComponent.limitedCountAccessible > 0 ? -1 : undefined;\n    var restrictionRemoved = newTabIndex === undefined;\n\n    if (storedComponent.curTabIndex !== newTabIndex || storedComponent.curAriaHidden !== newAriaHidden) {\n      var el = ReactDOM.findDOMNode(storedComponent.component);\n\n      if (el) {\n        if (storedComponent.curTabIndex !== newTabIndex) {\n          storedComponent.curTabIndex = newTabIndex;\n\n          if (restrictionRemoved) {\n            FocusManager._setTabIndex(el, storedComponent.origTabIndex);\n          } else {\n            var prevTabIndex = FocusManager._setTabIndex(el, newTabIndex);\n\n            if (!('origTabIndex' in storedComponent)) {\n              storedComponent.origTabIndex = prevTabIndex;\n            }\n          }\n        }\n\n        if (storedComponent.curAriaHidden !== newAriaHidden) {\n          storedComponent.curAriaHidden = newAriaHidden;\n\n          if (restrictionRemoved) {\n            FocusManager._setAriaHidden(el, storedComponent.origAriaHidden);\n          } else {\n            var prevAriaHidden = FocusManager._setAriaHidden(el, newAriaHidden ? 'true' : undefined);\n\n            if (!('origAriaHidden' in storedComponent)) {\n              storedComponent.origAriaHidden = prevAriaHidden;\n            }\n          }\n        }\n\n        if (restrictionRemoved) {\n          delete storedComponent.origTabIndex;\n          delete storedComponent.origAriaHidden;\n        }\n      }\n\n      FocusManager._callFocusableComponentStateChangeCallbacks(storedComponent, !restrictionRemoved);\n    }\n  };\n\n  FocusManager._setTabIndex = function (element, value) {\n    // If a tabIndex assignment is pending for this element, cancel it now.\n    if (FocusManager._setTabIndexTimer && element === FocusManager._setTabIndexElement) {\n      Timers_1.default.clearTimeout(FocusManager._setTabIndexTimer);\n      FocusManager._setTabIndexTimer = undefined;\n      FocusManager._setTabIndexElement = undefined;\n    }\n\n    var prev = element.hasAttribute(ATTR_NAME_TAB_INDEX) ? element.tabIndex : undefined;\n\n    if (value === undefined) {\n      if (prev !== undefined) {\n        element.removeAttribute(ATTR_NAME_TAB_INDEX);\n      }\n    } else if (value !== prev) {\n      // Setting tabIndex to -1 on the active element would trigger sync layout. Defer it.\n      if (value === -1 && element === document.activeElement) {\n        // If a tabIndex assignment is pending for another element, run it now as we know\n        // that it's not active anymore.\n        if (FocusManager._setTabIndexTimer) {\n          FocusManager._setTabIndexElement.tabIndex = -1;\n          Timers_1.default.clearTimeout(FocusManager._setTabIndexTimer);\n          FocusManager._setTabIndexTimer = undefined;\n          FocusManager._setTabIndexElement = undefined;\n        }\n\n        FocusManager._setTabIndexElement = element;\n        FocusManager._setTabIndexTimer = Timers_1.default.setTimeout(function () {\n          element.tabIndex = value;\n\n          if (element === FocusManager._setTabIndexElement) {\n            FocusManager._setTabIndexTimer = undefined;\n            FocusManager._setTabIndexElement = undefined;\n          }\n        }, 0);\n      } else {\n        element.tabIndex = value;\n      }\n    }\n\n    return prev;\n  };\n\n  FocusManager._setAriaHidden = function (element, value) {\n    var prev = element.hasAttribute(ATTR_NAME_ARIA_HIDDEN) ? element.getAttribute(ATTR_NAME_ARIA_HIDDEN) || undefined : undefined;\n\n    if (value === undefined) {\n      if (prev !== undefined) {\n        element.removeAttribute(ATTR_NAME_ARIA_HIDDEN);\n      }\n    } else {\n      element.setAttribute(ATTR_NAME_ARIA_HIDDEN, value);\n    }\n\n    return prev;\n  };\n\n  FocusManager.sortAndFilterAutoFocusCandidates = function (candidates) {\n    return candidates.filter(function (candidate) {\n      var id = candidate.component.focusableComponentId;\n\n      if (id) {\n        var storedComponent = FocusManager._allFocusableComponents[id];\n\n        if (storedComponent && (storedComponent.removed || storedComponent.limitedCount > 0 || storedComponent.limitedCountAccessible > 0)) {\n          return false;\n        }\n      }\n\n      return true;\n    }).map(function (candidate) {\n      return {\n        candidate: candidate,\n        el: ReactDOM.findDOMNode(candidate.component)\n      };\n    }).sort(function (a, b) {\n      // Some element which is mounted later could come earlier in the DOM,\n      // so, we sort the elements by their appearance in the DOM.\n      if (a === b) {\n        return 0;\n      }\n\n      return a.el.compareDocumentPosition(b.el) & document.DOCUMENT_POSITION_PRECEDING ? 1 : -1;\n    }).map(function (ce) {\n      return ce.candidate;\n    });\n  };\n\n  return FocusManager;\n}(FocusManager_1.FocusManager);\n\nexports.FocusManager = FocusManager;\n\nfunction applyFocusableComponentMixin(Component, isConditionallyFocusable) {\n  FocusManager_1.applyFocusableComponentMixin(Component, isConditionallyFocusable);\n  var origFocus = Component.prototype.focus;\n\n  if (origFocus) {\n    Component.prototype.focus = function () {\n      try {\n        var el = ReactDOM.findDOMNode(this);\n\n        if (el) {\n          FocusManager.setLastFocusedProgrammatically(el);\n        }\n      } catch (_a) {// Swallow exception due to component unmount race condition.\n      }\n\n      origFocus.apply(this, arguments);\n    };\n  }\n}\n\nexports.applyFocusableComponentMixin = applyFocusableComponentMixin;\n\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\n  FocusManager.initListeners();\n}\n\nexports.default = FocusManager;","map":{"version":3,"sources":["/Users/dangthang/Desktop/webStreamGame/node_modules/react-ult/dist/web/utils/FocusManager.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__","constructor","create","defineProperty","exports","value","applyFocusableComponentMixin","FocusManager","ReactDOM","require","AutoFocusHelper_1","FocusManager_1","Timers_1","UserInterface_1","ATTR_NAME_TAB_INDEX","ATTR_NAME_ARIA_HIDDEN","_isShiftPressed","_super","parent","initListeners","_checkFocusTimer","window","addEventListener","event","shiftKey","document","body","default","isNavigatingWithKeyboard","target","clearTimeout","_skipFocusCheck","setTimeout","undefined","_currentFocusedComponent","removed","activeElement","focusFirst","addFocusListenerOnComponent","component","onFocus","el","findDOMNode","_a","removeFocusListenerFromComponent","removeEventListener","focusComponent","focus","setLastFocusedProgrammatically","element","_lastFocusedProgrammatically","getLastFocusedProgrammatically","reset","ret","_isComponentAvailable","storedComponent","accessibleOnly","restricted","limitedCount","limitedCountAccessible","_getFirstFocusable","last","focusable","keys","_allFocusableComponents","filter","componentId","_myFocusableComponentIds","map","f","tabIndex","disabled","length","sort","a","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","first","storedComponent_1","FocusArbitratorProvider","requestFocus","FocusCandidateType","FocusFirst","resetFocus","focusFirstWhenNavigatingWithKeyboard","_resetFocusTimer","first_1","_currentRestrictionOwner","storedComponent_2","blur","currentFocused","prevTabIndex","_setTabIndex","_updateComponentFocusRestriction","newAriaHidden","newTabIndex","restrictionRemoved","curTabIndex","curAriaHidden","origTabIndex","_setAriaHidden","origAriaHidden","prevAriaHidden","_callFocusableComponentStateChangeCallbacks","_setTabIndexTimer","_setTabIndexElement","prev","hasAttribute","removeAttribute","getAttribute","setAttribute","sortAndFilterAutoFocusCandidates","candidates","candidate","id","focusableComponentId","ce","Component","isConditionallyFocusable","origFocus","apply","arguments"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/**\r\n * FocusManager.ts\r\n *\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n *\r\n * Manages focusable elements for better keyboard navigation (web version)\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.applyFocusableComponentMixin = exports.FocusManager = void 0;\r\nvar ReactDOM = require(\"react-dom\");\r\nvar AutoFocusHelper_1 = require(\"../../common/utils/AutoFocusHelper\");\r\nvar FocusManager_1 = require(\"../../common/utils/FocusManager\");\r\nvar Timers_1 = require(\"../../common/utils/Timers\");\r\nvar UserInterface_1 = require(\"../UserInterface\");\r\nvar ATTR_NAME_TAB_INDEX = 'tabindex';\r\nvar ATTR_NAME_ARIA_HIDDEN = 'aria-hidden';\r\nvar _isShiftPressed;\r\nvar FocusManager = /** @class */ (function (_super) {\r\n    __extends(FocusManager, _super);\r\n    function FocusManager(parent) {\r\n        return _super.call(this, parent) || this;\r\n    }\r\n    // Not really public\r\n    FocusManager.initListeners = function () {\r\n        // The default behaviour on Electron is to release the focus after the\r\n        // Tab key is pressed on a last focusable element in the page and focus\r\n        // the first focusable element on a consecutive Tab key press.\r\n        // We want to avoid losing this first Tab key press.\r\n        var _checkFocusTimer;\r\n        // Checking if Shift is pressed to move the focus into the right direction.\r\n        window.addEventListener('keydown', function (event) {\r\n            _isShiftPressed = event.shiftKey;\r\n        });\r\n        window.addEventListener('keyup', function (event) {\r\n            _isShiftPressed = event.shiftKey;\r\n        });\r\n        document.body.addEventListener('focusout', function (event) {\r\n            if (!UserInterface_1.default.isNavigatingWithKeyboard() || (event.target === document.body)) {\r\n                return;\r\n            }\r\n            if (_checkFocusTimer) {\r\n                Timers_1.default.clearTimeout(_checkFocusTimer);\r\n            }\r\n            if (FocusManager._skipFocusCheck) {\r\n                // When in between the FocusManager restrictions,\r\n                // don't check for the focus change here, FocusManager\r\n                // will take care of it.\r\n                FocusManager._skipFocusCheck = false;\r\n                return;\r\n            }\r\n            _checkFocusTimer = Timers_1.default.setTimeout(function () {\r\n                _checkFocusTimer = undefined;\r\n                if (UserInterface_1.default.isNavigatingWithKeyboard() &&\r\n                    (!FocusManager._currentFocusedComponent || !FocusManager._currentFocusedComponent.removed) &&\r\n                    (!document.activeElement || (document.activeElement === document.body))) {\r\n                    // This should work for Electron and the browser should\r\n                    // send the focus to the address bar anyway.\r\n                    FocusManager.focusFirst(_isShiftPressed);\r\n                }\r\n            }, 100);\r\n        });\r\n    };\r\n    FocusManager.prototype.addFocusListenerOnComponent = function (component, onFocus) {\r\n        try {\r\n            var el = ReactDOM.findDOMNode(component);\r\n            if (el) {\r\n                el.addEventListener('focus', onFocus);\r\n            }\r\n        }\r\n        catch (_a) {\r\n            // Swallow exception due to component unmount race condition.\r\n        }\r\n    };\r\n    FocusManager.prototype.removeFocusListenerFromComponent = function (component, onFocus) {\r\n        try {\r\n            var el = ReactDOM.findDOMNode(component);\r\n            if (el) {\r\n                el.removeEventListener('focus', onFocus);\r\n            }\r\n        }\r\n        catch (_a) {\r\n            // Swallow exception due to component unmount race condition.\r\n        }\r\n    };\r\n    FocusManager.prototype.focusComponent = function (component) {\r\n        try {\r\n            var el = ReactDOM.findDOMNode(component);\r\n            if (el && el.focus) {\r\n                FocusManager.setLastFocusedProgrammatically(el);\r\n                el.focus();\r\n                return true;\r\n            }\r\n        }\r\n        catch (_a) {\r\n            // Swallow exception due to component unmount race condition.\r\n        }\r\n        return false;\r\n    };\r\n    FocusManager.setLastFocusedProgrammatically = function (element) {\r\n        this._lastFocusedProgrammatically = element;\r\n    };\r\n    FocusManager.getLastFocusedProgrammatically = function (reset) {\r\n        var ret = FocusManager._lastFocusedProgrammatically;\r\n        if (ret && reset) {\r\n            FocusManager._lastFocusedProgrammatically = undefined;\r\n        }\r\n        return ret;\r\n    };\r\n    FocusManager._isComponentAvailable = function (storedComponent) {\r\n        return !storedComponent.accessibleOnly &&\r\n            !storedComponent.removed &&\r\n            !storedComponent.restricted &&\r\n            storedComponent.limitedCount === 0 &&\r\n            storedComponent.limitedCountAccessible === 0;\r\n    };\r\n    FocusManager._getFirstFocusable = function (last, parent) {\r\n        var focusable = Object.keys(FocusManager._allFocusableComponents)\r\n            .filter(function (componentId) { return !parent || (componentId in parent._myFocusableComponentIds); })\r\n            .map(function (componentId) { return FocusManager._allFocusableComponents[componentId]; })\r\n            .filter(FocusManager._isComponentAvailable)\r\n            .map(function (storedComponent) { return ({ storedComponent: storedComponent, el: ReactDOM.findDOMNode(storedComponent.component) }); })\r\n            .filter(function (f) { return f.el && f.el.focus && ((f.el.tabIndex || 0) >= 0) && !f.el.disabled; });\r\n        if (focusable.length) {\r\n            focusable.sort(function (a, b) {\r\n                // Some element which is mounted later could come earlier in the DOM,\r\n                // so, we sort the elements by their appearance in the DOM.\r\n                if (a === b) {\r\n                    return 0;\r\n                }\r\n                return a.el.compareDocumentPosition(b.el) & document.DOCUMENT_POSITION_PRECEDING ? 1 : -1;\r\n            });\r\n            return focusable[last ? focusable.length - 1 : 0];\r\n        }\r\n        return undefined;\r\n    };\r\n    FocusManager.focusFirst = function (last) {\r\n        var first = FocusManager._getFirstFocusable(last);\r\n        if (first) {\r\n            var storedComponent_1 = first.storedComponent;\r\n            AutoFocusHelper_1.FocusArbitratorProvider.requestFocus(storedComponent_1.component, function () {\r\n                FocusManager.setLastFocusedProgrammatically(first.el);\r\n                first.el.focus();\r\n            }, function () { return FocusManager._isComponentAvailable(storedComponent_1); }, AutoFocusHelper_1.FocusCandidateType.FocusFirst);\r\n        }\r\n    };\r\n    FocusManager.prototype.resetFocus = function (focusFirstWhenNavigatingWithKeyboard) {\r\n        if (FocusManager._resetFocusTimer) {\r\n            Timers_1.default.clearTimeout(FocusManager._resetFocusTimer);\r\n            FocusManager._resetFocusTimer = undefined;\r\n        }\r\n        if (UserInterface_1.default.isNavigatingWithKeyboard() && focusFirstWhenNavigatingWithKeyboard) {\r\n            // When we're in the keyboard navigation mode, we want to have the\r\n            // first focusable component to be focused straight away, without the\r\n            // necessity to press Tab.\r\n            var first_1 = FocusManager._getFirstFocusable(false, FocusManager._currentRestrictionOwner);\r\n            if (first_1) {\r\n                var storedComponent_2 = first_1.storedComponent;\r\n                AutoFocusHelper_1.FocusArbitratorProvider.requestFocus(storedComponent_2.component, function () {\r\n                    FocusManager.setLastFocusedProgrammatically(first_1.el);\r\n                    first_1.el.focus();\r\n                }, function () { return FocusManager._isComponentAvailable(storedComponent_2); }, AutoFocusHelper_1.FocusCandidateType.FocusFirst);\r\n            }\r\n        }\r\n        else if ((typeof document !== 'undefined') && document.body && document.body.focus && document.body.blur) {\r\n            // An example to explain this part:\r\n            // We've shown a modal dialog which is higher in the DOM by clicking\r\n            // on a button which is lower in the DOM, we've applied the restrictions\r\n            // and only the elements from the modal dialog are focusable now.\r\n            // But internally the browser keeps the last focus position in the DOM\r\n            // (even if we do blur() for the button) and when Tab is pressed again,\r\n            // the browser will start searching for the next focusable element from\r\n            // this position.\r\n            // This means that the first Tab press will get us to the browser's address\r\n            // bar (or nowhere in case of Electron) and only the second Tab press will\r\n            // lead us to focusing the first focusable element in the modal dialog.\r\n            // In order to avoid losing this first Tab press, we're making <body>\r\n            // focusable, focusing it, removing the focus and making it unfocusable\r\n            // back again.\r\n            // Defer the work to avoid triggering sync layout.\r\n            FocusManager._resetFocusTimer = Timers_1.default.setTimeout(function () {\r\n                FocusManager._resetFocusTimer = undefined;\r\n                var currentFocused = FocusManager._currentFocusedComponent;\r\n                if (currentFocused && !currentFocused.removed && !currentFocused.restricted) {\r\n                    // No need to reset the focus because it's moved inside the restricted area\r\n                    // already (manually or with autofocus).\r\n                    return;\r\n                }\r\n                var prevTabIndex = FocusManager._setTabIndex(document.body, -1);\r\n                FocusManager.setLastFocusedProgrammatically(document.body);\r\n                document.body.focus();\r\n                document.body.blur();\r\n                FocusManager._setTabIndex(document.body, prevTabIndex);\r\n            }, 100);\r\n        }\r\n    };\r\n    FocusManager.prototype._updateComponentFocusRestriction = function (storedComponent) {\r\n        var newAriaHidden = storedComponent.restricted || (storedComponent.limitedCount > 0) ? true : undefined;\r\n        var newTabIndex = newAriaHidden || (storedComponent.limitedCountAccessible > 0) ? -1 : undefined;\r\n        var restrictionRemoved = newTabIndex === undefined;\r\n        if ((storedComponent.curTabIndex !== newTabIndex) || (storedComponent.curAriaHidden !== newAriaHidden)) {\r\n            var el = ReactDOM.findDOMNode(storedComponent.component);\r\n            if (el) {\r\n                if (storedComponent.curTabIndex !== newTabIndex) {\r\n                    storedComponent.curTabIndex = newTabIndex;\r\n                    if (restrictionRemoved) {\r\n                        FocusManager._setTabIndex(el, storedComponent.origTabIndex);\r\n                    }\r\n                    else {\r\n                        var prevTabIndex = FocusManager._setTabIndex(el, newTabIndex);\r\n                        if (!('origTabIndex' in storedComponent)) {\r\n                            storedComponent.origTabIndex = prevTabIndex;\r\n                        }\r\n                    }\r\n                }\r\n                if (storedComponent.curAriaHidden !== newAriaHidden) {\r\n                    storedComponent.curAriaHidden = newAriaHidden;\r\n                    if (restrictionRemoved) {\r\n                        FocusManager._setAriaHidden(el, storedComponent.origAriaHidden);\r\n                    }\r\n                    else {\r\n                        var prevAriaHidden = FocusManager._setAriaHidden(el, newAriaHidden ? 'true' : undefined);\r\n                        if (!('origAriaHidden' in storedComponent)) {\r\n                            storedComponent.origAriaHidden = prevAriaHidden;\r\n                        }\r\n                    }\r\n                }\r\n                if (restrictionRemoved) {\r\n                    delete storedComponent.origTabIndex;\r\n                    delete storedComponent.origAriaHidden;\r\n                }\r\n            }\r\n            FocusManager._callFocusableComponentStateChangeCallbacks(storedComponent, !restrictionRemoved);\r\n        }\r\n    };\r\n    FocusManager._setTabIndex = function (element, value) {\r\n        // If a tabIndex assignment is pending for this element, cancel it now.\r\n        if (FocusManager._setTabIndexTimer && element === FocusManager._setTabIndexElement) {\r\n            Timers_1.default.clearTimeout(FocusManager._setTabIndexTimer);\r\n            FocusManager._setTabIndexTimer = undefined;\r\n            FocusManager._setTabIndexElement = undefined;\r\n        }\r\n        var prev = element.hasAttribute(ATTR_NAME_TAB_INDEX) ? element.tabIndex : undefined;\r\n        if (value === undefined) {\r\n            if (prev !== undefined) {\r\n                element.removeAttribute(ATTR_NAME_TAB_INDEX);\r\n            }\r\n        }\r\n        else if (value !== prev) {\r\n            // Setting tabIndex to -1 on the active element would trigger sync layout. Defer it.\r\n            if (value === -1 && element === document.activeElement) {\r\n                // If a tabIndex assignment is pending for another element, run it now as we know\r\n                // that it's not active anymore.\r\n                if (FocusManager._setTabIndexTimer) {\r\n                    FocusManager._setTabIndexElement.tabIndex = -1;\r\n                    Timers_1.default.clearTimeout(FocusManager._setTabIndexTimer);\r\n                    FocusManager._setTabIndexTimer = undefined;\r\n                    FocusManager._setTabIndexElement = undefined;\r\n                }\r\n                FocusManager._setTabIndexElement = element;\r\n                FocusManager._setTabIndexTimer = Timers_1.default.setTimeout(function () {\r\n                    element.tabIndex = value;\r\n                    if (element === FocusManager._setTabIndexElement) {\r\n                        FocusManager._setTabIndexTimer = undefined;\r\n                        FocusManager._setTabIndexElement = undefined;\r\n                    }\r\n                }, 0);\r\n            }\r\n            else {\r\n                element.tabIndex = value;\r\n            }\r\n        }\r\n        return prev;\r\n    };\r\n    FocusManager._setAriaHidden = function (element, value) {\r\n        var prev = element.hasAttribute(ATTR_NAME_ARIA_HIDDEN) ? element.getAttribute(ATTR_NAME_ARIA_HIDDEN) || undefined : undefined;\r\n        if (value === undefined) {\r\n            if (prev !== undefined) {\r\n                element.removeAttribute(ATTR_NAME_ARIA_HIDDEN);\r\n            }\r\n        }\r\n        else {\r\n            element.setAttribute(ATTR_NAME_ARIA_HIDDEN, value);\r\n        }\r\n        return prev;\r\n    };\r\n    FocusManager.sortAndFilterAutoFocusCandidates = function (candidates) {\r\n        return candidates\r\n            .filter(function (candidate) {\r\n            var id = candidate.component.focusableComponentId;\r\n            if (id) {\r\n                var storedComponent = FocusManager._allFocusableComponents[id];\r\n                if (storedComponent &&\r\n                    (storedComponent.removed ||\r\n                        (storedComponent.limitedCount > 0) || (storedComponent.limitedCountAccessible > 0))) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        })\r\n            .map(function (candidate) { return ({ candidate: candidate, el: ReactDOM.findDOMNode(candidate.component) }); })\r\n            .sort(function (a, b) {\r\n            // Some element which is mounted later could come earlier in the DOM,\r\n            // so, we sort the elements by their appearance in the DOM.\r\n            if (a === b) {\r\n                return 0;\r\n            }\r\n            return a.el.compareDocumentPosition(b.el) & document.DOCUMENT_POSITION_PRECEDING ? 1 : -1;\r\n        })\r\n            .map(function (ce) { return ce.candidate; });\r\n    };\r\n    return FocusManager;\r\n}(FocusManager_1.FocusManager));\r\nexports.FocusManager = FocusManager;\r\nfunction applyFocusableComponentMixin(Component, isConditionallyFocusable) {\r\n    FocusManager_1.applyFocusableComponentMixin(Component, isConditionallyFocusable);\r\n    var origFocus = Component.prototype.focus;\r\n    if (origFocus) {\r\n        Component.prototype.focus = function () {\r\n            try {\r\n                var el = ReactDOM.findDOMNode(this);\r\n                if (el) {\r\n                    FocusManager.setLastFocusedProgrammatically(el);\r\n                }\r\n            }\r\n            catch (_a) {\r\n                // Swallow exception due to component unmount race condition.\r\n            }\r\n            origFocus.apply(this, arguments);\r\n        };\r\n    }\r\n}\r\nexports.applyFocusableComponentMixin = applyFocusableComponentMixin;\r\nif ((typeof document !== 'undefined') && (typeof window !== 'undefined')) {\r\n    FocusManager.initListeners();\r\n}\r\nexports.default = FocusManager;\r\n"]},"metadata":{},"sourceType":"script"}