{"ast":null,"code":"\"use strict\";\n/**\r\n * FocusManager.ts\r\n *\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n *\r\n * Manages focusable elements for better keyboard navigation.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyFocusableComponentMixin = exports.FocusManager = exports.RestrictFocusType = void 0;\n\nvar PropTypes = require(\"prop-types\");\n\nvar AppConfig_1 = require(\"../../common/AppConfig\");\n\nvar Interfaces_1 = require(\"../../common/Interfaces\");\n\nvar Timers_1 = require(\"./Timers\");\n\nvar _lastComponentId = 0;\nvar RestrictFocusType;\n\n(function (RestrictFocusType) {\n  RestrictFocusType[RestrictFocusType[\"Unrestricted\"] = 0] = \"Unrestricted\"; // When restrictFocusWithin=Restricted, the focus will not go outside of this View\n  // when you're using Tab navigation.\n\n  RestrictFocusType[RestrictFocusType[\"Restricted\"] = 1] = \"Restricted\"; // The same as Restricted, but will also focus first focusable component inside\n  // this View when UserInterface.isNavigatingWithKeyboard() is true, to save a Tab\n  // press for the cases the user is tabbing already.\n\n  RestrictFocusType[RestrictFocusType[\"RestrictedFocusFirst\"] = 2] = \"RestrictedFocusFirst\";\n})(RestrictFocusType = exports.RestrictFocusType || (exports.RestrictFocusType = {}));\n\nvar FocusManager =\n/** @class */\nfunction () {\n  function FocusManager(parent) {\n    this._isFocusLimited = Interfaces_1.Types.LimitFocusType.Unlimited;\n    this._currentRestrictType = RestrictFocusType.Unrestricted;\n    this._myFocusableComponentIds = {};\n    this._parent = parent;\n  } // Whenever the focusable element is mounted, we let the application\n  // know so that FocusManager could account for this element during the\n  // focus restriction.\n\n\n  FocusManager.prototype.addFocusableComponent = function (component, accessibleOnly) {\n    if (accessibleOnly === void 0) {\n      accessibleOnly = false;\n    }\n\n    if (component.focusableComponentId) {\n      return;\n    }\n\n    var numericComponentId = ++_lastComponentId;\n    var componentId = 'fc-' + numericComponentId;\n    var storedComponent = {\n      id: componentId,\n      numericId: numericComponentId,\n      component: component,\n      accessibleOnly: accessibleOnly,\n      restricted: false,\n      limitedCount: 0,\n      limitedCountAccessible: 0,\n      onFocus: function () {\n        FocusManager._currentFocusedComponent = storedComponent;\n      }\n    };\n    component.focusableComponentId = componentId;\n    FocusManager._allFocusableComponents[componentId] = storedComponent;\n    var withinRestrictionOwner = false;\n\n    for (var parent_1 = this; parent_1; parent_1 = parent_1._parent) {\n      parent_1._myFocusableComponentIds[componentId] = true;\n\n      if (FocusManager._currentRestrictionOwner === parent_1) {\n        withinRestrictionOwner = true;\n      }\n\n      if (parent_1._isFocusLimited === Interfaces_1.Types.LimitFocusType.Accessible) {\n        storedComponent.limitedCountAccessible++;\n      } else if (parent_1._isFocusLimited === Interfaces_1.Types.LimitFocusType.Limited) {\n        storedComponent.limitedCount++;\n      }\n    }\n\n    if (!withinRestrictionOwner && FocusManager._currentRestrictionOwner) {\n      storedComponent.restricted = true;\n    }\n\n    this._updateComponentFocusRestriction(storedComponent);\n\n    this.addFocusListenerOnComponent(component, storedComponent.onFocus);\n  };\n\n  FocusManager.prototype.removeFocusableComponent = function (component) {\n    if (!component.focusableComponentId) {\n      return;\n    }\n\n    var componentId = component.focusableComponentId;\n\n    if (componentId) {\n      var storedComponent = FocusManager._allFocusableComponents[componentId];\n      this.removeFocusListenerFromComponent(component, storedComponent.onFocus);\n      storedComponent.removed = true;\n      storedComponent.restricted = false;\n      storedComponent.limitedCount = 0;\n      storedComponent.limitedCountAccessible = 0;\n\n      this._updateComponentFocusRestriction(storedComponent);\n\n      delete storedComponent.callbacks;\n\n      for (var parent_2 = this; parent_2; parent_2 = parent_2._parent) {\n        delete parent_2._myFocusableComponentIds[componentId];\n      }\n\n      delete FocusManager._allFocusableComponents[componentId];\n      delete component.focusableComponentId;\n    }\n  };\n\n  FocusManager.prototype.restrictFocusWithin = function (restrictType, noFocusReset) {\n    var _this = this; // Limit the focus received by the keyboard navigation to all\n    // the descendant focusable elements by setting tabIndex of all\n    // other elements to -1.\n\n\n    if (FocusManager._currentRestrictionOwner === this || restrictType === RestrictFocusType.Unrestricted) {\n      return;\n    }\n\n    this._currentRestrictType = restrictType;\n\n    if (FocusManager._currentRestrictionOwner) {\n      this._removeFocusRestriction();\n    }\n\n    if (!this._prevFocusedComponent) {\n      this._prevFocusedComponent = FocusManager._pendingPrevFocusedComponent || FocusManager._currentFocusedComponent;\n    }\n\n    FocusManager._clearRestoreRestrictionTimeout();\n\n    FocusManager._restrictionStack.push(this);\n\n    FocusManager._currentRestrictionOwner = this;\n\n    if (!noFocusReset) {\n      this.resetFocus(restrictType === RestrictFocusType.RestrictedFocusFirst);\n    }\n\n    Object.keys(FocusManager._allFocusableComponents).forEach(function (componentId) {\n      if (!(componentId in _this._myFocusableComponentIds)) {\n        var storedComponent = FocusManager._allFocusableComponents[componentId];\n        storedComponent.restricted = true;\n\n        _this._updateComponentFocusRestriction(storedComponent);\n      }\n    });\n\n    if (this._restrictionStateCallback) {\n      this._restrictionStateCallback(restrictType);\n    }\n  };\n\n  FocusManager.prototype.removeFocusRestriction = function () {\n    var _this = this; // Restore the focus to the previous view with restrictFocusWithin or\n    // remove the restriction if there is no such view.\n\n\n    FocusManager._restrictionStack = FocusManager._restrictionStack.filter(function (focusManager) {\n      return focusManager !== _this;\n    });\n\n    if (FocusManager._currentRestrictionOwner === this) {\n      // We'll take care of setting the proper focus below,\n      // no need to do a regular check for focusout.\n      FocusManager._skipFocusCheck = true;\n      var prevFocusedComponent_1 = this._prevFocusedComponent;\n      this._prevFocusedComponent = undefined;\n\n      this._removeFocusRestriction();\n\n      FocusManager._currentRestrictionOwner = undefined;\n\n      if (this._restrictionStateCallback) {\n        this._restrictionStateCallback(RestrictFocusType.Unrestricted);\n      } // Defer the previous restriction restoration to wait for the current view\n      // to be unmounted, or for the next restricted view to be mounted (like\n      // showing a modal after a popup).\n\n\n      FocusManager._clearRestoreRestrictionTimeout();\n\n      FocusManager._pendingPrevFocusedComponent = prevFocusedComponent_1;\n      FocusManager._restoreRestrictionTimer = Timers_1.default.setTimeout(function () {\n        FocusManager._restoreRestrictionTimer = undefined;\n        FocusManager._pendingPrevFocusedComponent = undefined;\n\n        var prevRestrictionOwner = FocusManager._restrictionStack.pop();\n\n        var needsFocusReset = true;\n        var currentFocusedComponent = FocusManager._currentFocusedComponent;\n\n        if (currentFocusedComponent && !currentFocusedComponent.removed && !(currentFocusedComponent.id in _this._myFocusableComponentIds)) {\n          // The focus has been manually moved to something outside of the current\n          // restriction scope, we should skip focusing the component which was\n          // focused before the restriction and keep the focus as it is.\n          prevFocusedComponent_1 = undefined;\n          needsFocusReset = false;\n        }\n\n        if (prevFocusedComponent_1 && !prevFocusedComponent_1.accessibleOnly && !prevFocusedComponent_1.removed && !prevFocusedComponent_1.restricted && prevFocusedComponent_1.limitedCount === 0 && prevFocusedComponent_1.limitedCountAccessible === 0) {\n          // If possible, focus the previously focused component.\n          needsFocusReset = !_this.focusComponent(prevFocusedComponent_1.component);\n        }\n\n        if (prevRestrictionOwner) {\n          prevRestrictionOwner.restrictFocusWithin(prevRestrictionOwner._currentRestrictType, !needsFocusReset);\n        } else if (needsFocusReset) {\n          _this.resetFocus(_this._currentRestrictType === RestrictFocusType.RestrictedFocusFirst);\n        }\n      }, 100);\n    }\n  };\n\n  FocusManager.prototype.limitFocusWithin = function (limitType) {\n    var _this = this;\n\n    if (this._isFocusLimited !== Interfaces_1.Types.LimitFocusType.Unlimited || limitType !== Interfaces_1.Types.LimitFocusType.Limited && limitType !== Interfaces_1.Types.LimitFocusType.Accessible) {\n      return;\n    }\n\n    this._isFocusLimited = limitType;\n    Object.keys(this._myFocusableComponentIds).forEach(function (componentId) {\n      var storedComponent = FocusManager._allFocusableComponents[componentId];\n\n      if (limitType === Interfaces_1.Types.LimitFocusType.Accessible) {\n        storedComponent.limitedCountAccessible++;\n      } else if (limitType === Interfaces_1.Types.LimitFocusType.Limited) {\n        storedComponent.limitedCount++;\n      }\n\n      _this._updateComponentFocusRestriction(storedComponent);\n    });\n  };\n\n  FocusManager.prototype.removeFocusLimitation = function () {\n    var _this = this;\n\n    if (this._isFocusLimited === Interfaces_1.Types.LimitFocusType.Unlimited) {\n      return;\n    }\n\n    Object.keys(this._myFocusableComponentIds).forEach(function (componentId) {\n      var storedComponent = FocusManager._allFocusableComponents[componentId];\n\n      if (_this._isFocusLimited === Interfaces_1.Types.LimitFocusType.Accessible) {\n        storedComponent.limitedCountAccessible--;\n      } else if (_this._isFocusLimited === Interfaces_1.Types.LimitFocusType.Limited) {\n        storedComponent.limitedCount--;\n      }\n\n      _this._updateComponentFocusRestriction(storedComponent);\n    });\n    this._isFocusLimited = Interfaces_1.Types.LimitFocusType.Unlimited;\n  };\n\n  FocusManager.prototype.release = function () {\n    this.removeFocusRestriction();\n    this.removeFocusLimitation();\n  };\n\n  FocusManager.subscribe = function (component, callback) {\n    var storedComponent = FocusManager._getStoredComponent(component);\n\n    if (storedComponent) {\n      if (!storedComponent.callbacks) {\n        storedComponent.callbacks = [];\n      }\n\n      storedComponent.callbacks.push(callback);\n    }\n  };\n\n  FocusManager.unsubscribe = function (component, callback) {\n    var storedComponent = FocusManager._getStoredComponent(component);\n\n    if (storedComponent && storedComponent.callbacks) {\n      storedComponent.callbacks = storedComponent.callbacks.filter(function (cb) {\n        return cb !== callback;\n      });\n    }\n  };\n\n  FocusManager.prototype.setRestrictionStateCallback = function (callback) {\n    this._restrictionStateCallback = callback;\n  };\n\n  FocusManager.isComponentFocusRestrictedOrLimited = function (component) {\n    var storedComponent = FocusManager._getStoredComponent(component);\n\n    return !!storedComponent && (storedComponent.restricted || storedComponent.limitedCount > 0 || storedComponent.limitedCountAccessible > 0);\n  };\n\n  FocusManager.getCurrentFocusedComponent = function () {\n    return FocusManager._currentFocusedComponent ? FocusManager._currentFocusedComponent.id : undefined;\n  };\n\n  FocusManager._getStoredComponent = function (component) {\n    var componentId = component.focusableComponentId;\n\n    if (componentId) {\n      return FocusManager._allFocusableComponents[componentId];\n    }\n\n    return undefined;\n  };\n\n  FocusManager._callFocusableComponentStateChangeCallbacks = function (storedComponent, restrictedOrLimited) {\n    if (!storedComponent.callbacks) {\n      return;\n    }\n\n    storedComponent.callbacks.forEach(function (callback) {\n      callback.call(storedComponent.component, restrictedOrLimited);\n    });\n  };\n\n  FocusManager.prototype._removeFocusRestriction = function () {\n    var _this = this;\n\n    Object.keys(FocusManager._allFocusableComponents).forEach(function (componentId) {\n      var storedComponent = FocusManager._allFocusableComponents[componentId];\n      storedComponent.restricted = false;\n\n      _this._updateComponentFocusRestriction(storedComponent);\n    });\n  };\n\n  FocusManager._clearRestoreRestrictionTimeout = function () {\n    if (FocusManager._restoreRestrictionTimer) {\n      Timers_1.default.clearTimeout(FocusManager._restoreRestrictionTimer);\n      FocusManager._restoreRestrictionTimer = undefined;\n      FocusManager._pendingPrevFocusedComponent = undefined;\n    }\n  };\n\n  FocusManager._restrictionStack = [];\n  FocusManager._allFocusableComponents = {};\n  FocusManager._skipFocusCheck = false;\n  return FocusManager;\n}();\n\nexports.FocusManager = FocusManager; // A mixin for the focusable elements, to tell the views that\n// they exist and should be accounted during the focus restriction.\n//\n// isConditionallyFocusable is an optional callback which will be\n// called for componentDidMount() or for UNSAFE_componentWillUpdate() to\n// determine if the component is actually focusable.\n//\n// accessibleOnly is true for components that support just being focused\n// by screen readers.\n// By default components support both screen reader and keyboard focusing.\n\nfunction applyFocusableComponentMixin(Component, isConditionallyFocusable, accessibleOnly) {\n  if (accessibleOnly === void 0) {\n    accessibleOnly = false;\n  }\n\n  var contextTypes = Component.contextTypes || {};\n  contextTypes.focusManager = PropTypes.object;\n  Component.contextTypes = contextTypes;\n  inheritMethod('componentDidMount', function (focusManager) {\n    if (!isConditionallyFocusable || isConditionallyFocusable.call(this)) {\n      focusManager.addFocusableComponent(this, accessibleOnly);\n    }\n  });\n  inheritMethod('componentWillUnmount', function (focusManager) {\n    focusManager.removeFocusableComponent(this);\n  });\n  inheritMethod('UNSAFE_componentWillUpdate', function (focusManager, origArgs) {\n    if (isConditionallyFocusable) {\n      var isFocusable = isConditionallyFocusable.apply(this, origArgs);\n\n      if (isFocusable && !this.focusableComponentId) {\n        focusManager.addFocusableComponent(this, accessibleOnly);\n      } else if (!isFocusable && this.focusableComponentId) {\n        focusManager.removeFocusableComponent(this);\n      }\n    }\n  });\n\n  function inheritMethod(methodName, action) {\n    var origCallback = Component.prototype[methodName];\n\n    Component.prototype[methodName] = function () {\n      if (!isConditionallyFocusable || isConditionallyFocusable.call(this)) {\n        var focusManager = this._focusManager || this.context && this.context.focusManager;\n\n        if (focusManager) {\n          action.call(this, focusManager, arguments);\n        } else {\n          if (AppConfig_1.default.isDevelopmentMode()) {\n            console.error('FocusableComponentMixin: context error!');\n          }\n        }\n      }\n\n      if (origCallback) {\n        origCallback.apply(this, arguments);\n      }\n    };\n  }\n}\n\nexports.applyFocusableComponentMixin = applyFocusableComponentMixin;\nexports.default = FocusManager;","map":{"version":3,"sources":["/Users/dangthang/Desktop/webStreamGame/node_modules/react-ult/dist/common/utils/FocusManager.js"],"names":["Object","defineProperty","exports","value","applyFocusableComponentMixin","FocusManager","RestrictFocusType","PropTypes","require","AppConfig_1","Interfaces_1","Timers_1","_lastComponentId","parent","_isFocusLimited","Types","LimitFocusType","Unlimited","_currentRestrictType","Unrestricted","_myFocusableComponentIds","_parent","prototype","addFocusableComponent","component","accessibleOnly","focusableComponentId","numericComponentId","componentId","storedComponent","id","numericId","restricted","limitedCount","limitedCountAccessible","onFocus","_currentFocusedComponent","_allFocusableComponents","withinRestrictionOwner","parent_1","_currentRestrictionOwner","Accessible","Limited","_updateComponentFocusRestriction","addFocusListenerOnComponent","removeFocusableComponent","removeFocusListenerFromComponent","removed","callbacks","parent_2","restrictFocusWithin","restrictType","noFocusReset","_this","_removeFocusRestriction","_prevFocusedComponent","_pendingPrevFocusedComponent","_clearRestoreRestrictionTimeout","_restrictionStack","push","resetFocus","RestrictedFocusFirst","keys","forEach","_restrictionStateCallback","removeFocusRestriction","filter","focusManager","_skipFocusCheck","prevFocusedComponent_1","undefined","_restoreRestrictionTimer","default","setTimeout","prevRestrictionOwner","pop","needsFocusReset","currentFocusedComponent","focusComponent","limitFocusWithin","limitType","removeFocusLimitation","release","subscribe","callback","_getStoredComponent","unsubscribe","cb","setRestrictionStateCallback","isComponentFocusRestrictedOrLimited","getCurrentFocusedComponent","_callFocusableComponentStateChangeCallbacks","restrictedOrLimited","call","clearTimeout","Component","isConditionallyFocusable","contextTypes","object","inheritMethod","origArgs","isFocusable","apply","methodName","action","origCallback","_focusManager","context","arguments","isDevelopmentMode","console","error"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/**\r\n * FocusManager.ts\r\n *\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n *\r\n * Manages focusable elements for better keyboard navigation.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.applyFocusableComponentMixin = exports.FocusManager = exports.RestrictFocusType = void 0;\r\nvar PropTypes = require(\"prop-types\");\r\nvar AppConfig_1 = require(\"../../common/AppConfig\");\r\nvar Interfaces_1 = require(\"../../common/Interfaces\");\r\nvar Timers_1 = require(\"./Timers\");\r\nvar _lastComponentId = 0;\r\nvar RestrictFocusType;\r\n(function (RestrictFocusType) {\r\n    RestrictFocusType[RestrictFocusType[\"Unrestricted\"] = 0] = \"Unrestricted\";\r\n    // When restrictFocusWithin=Restricted, the focus will not go outside of this View\r\n    // when you're using Tab navigation.\r\n    RestrictFocusType[RestrictFocusType[\"Restricted\"] = 1] = \"Restricted\";\r\n    // The same as Restricted, but will also focus first focusable component inside\r\n    // this View when UserInterface.isNavigatingWithKeyboard() is true, to save a Tab\r\n    // press for the cases the user is tabbing already.\r\n    RestrictFocusType[RestrictFocusType[\"RestrictedFocusFirst\"] = 2] = \"RestrictedFocusFirst\";\r\n})(RestrictFocusType = exports.RestrictFocusType || (exports.RestrictFocusType = {}));\r\nvar FocusManager = /** @class */ (function () {\r\n    function FocusManager(parent) {\r\n        this._isFocusLimited = Interfaces_1.Types.LimitFocusType.Unlimited;\r\n        this._currentRestrictType = RestrictFocusType.Unrestricted;\r\n        this._myFocusableComponentIds = {};\r\n        this._parent = parent;\r\n    }\r\n    // Whenever the focusable element is mounted, we let the application\r\n    // know so that FocusManager could account for this element during the\r\n    // focus restriction.\r\n    FocusManager.prototype.addFocusableComponent = function (component, accessibleOnly) {\r\n        if (accessibleOnly === void 0) { accessibleOnly = false; }\r\n        if (component.focusableComponentId) {\r\n            return;\r\n        }\r\n        var numericComponentId = ++_lastComponentId;\r\n        var componentId = 'fc-' + numericComponentId;\r\n        var storedComponent = {\r\n            id: componentId,\r\n            numericId: numericComponentId,\r\n            component: component,\r\n            accessibleOnly: accessibleOnly,\r\n            restricted: false,\r\n            limitedCount: 0,\r\n            limitedCountAccessible: 0,\r\n            onFocus: function () {\r\n                FocusManager._currentFocusedComponent = storedComponent;\r\n            },\r\n        };\r\n        component.focusableComponentId = componentId;\r\n        FocusManager._allFocusableComponents[componentId] = storedComponent;\r\n        var withinRestrictionOwner = false;\r\n        for (var parent_1 = this; parent_1; parent_1 = parent_1._parent) {\r\n            parent_1._myFocusableComponentIds[componentId] = true;\r\n            if (FocusManager._currentRestrictionOwner === parent_1) {\r\n                withinRestrictionOwner = true;\r\n            }\r\n            if (parent_1._isFocusLimited === Interfaces_1.Types.LimitFocusType.Accessible) {\r\n                storedComponent.limitedCountAccessible++;\r\n            }\r\n            else if (parent_1._isFocusLimited === Interfaces_1.Types.LimitFocusType.Limited) {\r\n                storedComponent.limitedCount++;\r\n            }\r\n        }\r\n        if (!withinRestrictionOwner && FocusManager._currentRestrictionOwner) {\r\n            storedComponent.restricted = true;\r\n        }\r\n        this._updateComponentFocusRestriction(storedComponent);\r\n        this.addFocusListenerOnComponent(component, storedComponent.onFocus);\r\n    };\r\n    FocusManager.prototype.removeFocusableComponent = function (component) {\r\n        if (!component.focusableComponentId) {\r\n            return;\r\n        }\r\n        var componentId = component.focusableComponentId;\r\n        if (componentId) {\r\n            var storedComponent = FocusManager._allFocusableComponents[componentId];\r\n            this.removeFocusListenerFromComponent(component, storedComponent.onFocus);\r\n            storedComponent.removed = true;\r\n            storedComponent.restricted = false;\r\n            storedComponent.limitedCount = 0;\r\n            storedComponent.limitedCountAccessible = 0;\r\n            this._updateComponentFocusRestriction(storedComponent);\r\n            delete storedComponent.callbacks;\r\n            for (var parent_2 = this; parent_2; parent_2 = parent_2._parent) {\r\n                delete parent_2._myFocusableComponentIds[componentId];\r\n            }\r\n            delete FocusManager._allFocusableComponents[componentId];\r\n            delete component.focusableComponentId;\r\n        }\r\n    };\r\n    FocusManager.prototype.restrictFocusWithin = function (restrictType, noFocusReset) {\r\n        var _this = this;\r\n        // Limit the focus received by the keyboard navigation to all\r\n        // the descendant focusable elements by setting tabIndex of all\r\n        // other elements to -1.\r\n        if ((FocusManager._currentRestrictionOwner === this) || (restrictType === RestrictFocusType.Unrestricted)) {\r\n            return;\r\n        }\r\n        this._currentRestrictType = restrictType;\r\n        if (FocusManager._currentRestrictionOwner) {\r\n            this._removeFocusRestriction();\r\n        }\r\n        if (!this._prevFocusedComponent) {\r\n            this._prevFocusedComponent = FocusManager._pendingPrevFocusedComponent || FocusManager._currentFocusedComponent;\r\n        }\r\n        FocusManager._clearRestoreRestrictionTimeout();\r\n        FocusManager._restrictionStack.push(this);\r\n        FocusManager._currentRestrictionOwner = this;\r\n        if (!noFocusReset) {\r\n            this.resetFocus(restrictType === RestrictFocusType.RestrictedFocusFirst);\r\n        }\r\n        Object.keys(FocusManager._allFocusableComponents).forEach(function (componentId) {\r\n            if (!(componentId in _this._myFocusableComponentIds)) {\r\n                var storedComponent = FocusManager._allFocusableComponents[componentId];\r\n                storedComponent.restricted = true;\r\n                _this._updateComponentFocusRestriction(storedComponent);\r\n            }\r\n        });\r\n        if (this._restrictionStateCallback) {\r\n            this._restrictionStateCallback(restrictType);\r\n        }\r\n    };\r\n    FocusManager.prototype.removeFocusRestriction = function () {\r\n        var _this = this;\r\n        // Restore the focus to the previous view with restrictFocusWithin or\r\n        // remove the restriction if there is no such view.\r\n        FocusManager._restrictionStack = FocusManager._restrictionStack.filter(function (focusManager) { return focusManager !== _this; });\r\n        if (FocusManager._currentRestrictionOwner === this) {\r\n            // We'll take care of setting the proper focus below,\r\n            // no need to do a regular check for focusout.\r\n            FocusManager._skipFocusCheck = true;\r\n            var prevFocusedComponent_1 = this._prevFocusedComponent;\r\n            this._prevFocusedComponent = undefined;\r\n            this._removeFocusRestriction();\r\n            FocusManager._currentRestrictionOwner = undefined;\r\n            if (this._restrictionStateCallback) {\r\n                this._restrictionStateCallback(RestrictFocusType.Unrestricted);\r\n            }\r\n            // Defer the previous restriction restoration to wait for the current view\r\n            // to be unmounted, or for the next restricted view to be mounted (like\r\n            // showing a modal after a popup).\r\n            FocusManager._clearRestoreRestrictionTimeout();\r\n            FocusManager._pendingPrevFocusedComponent = prevFocusedComponent_1;\r\n            FocusManager._restoreRestrictionTimer = Timers_1.default.setTimeout(function () {\r\n                FocusManager._restoreRestrictionTimer = undefined;\r\n                FocusManager._pendingPrevFocusedComponent = undefined;\r\n                var prevRestrictionOwner = FocusManager._restrictionStack.pop();\r\n                var needsFocusReset = true;\r\n                var currentFocusedComponent = FocusManager._currentFocusedComponent;\r\n                if (currentFocusedComponent && !currentFocusedComponent.removed &&\r\n                    !(currentFocusedComponent.id in _this._myFocusableComponentIds)) {\r\n                    // The focus has been manually moved to something outside of the current\r\n                    // restriction scope, we should skip focusing the component which was\r\n                    // focused before the restriction and keep the focus as it is.\r\n                    prevFocusedComponent_1 = undefined;\r\n                    needsFocusReset = false;\r\n                }\r\n                if (prevFocusedComponent_1 &&\r\n                    !prevFocusedComponent_1.accessibleOnly &&\r\n                    !prevFocusedComponent_1.removed &&\r\n                    !prevFocusedComponent_1.restricted &&\r\n                    prevFocusedComponent_1.limitedCount === 0 &&\r\n                    prevFocusedComponent_1.limitedCountAccessible === 0) {\r\n                    // If possible, focus the previously focused component.\r\n                    needsFocusReset = !_this.focusComponent(prevFocusedComponent_1.component);\r\n                }\r\n                if (prevRestrictionOwner) {\r\n                    prevRestrictionOwner.restrictFocusWithin(prevRestrictionOwner._currentRestrictType, !needsFocusReset);\r\n                }\r\n                else if (needsFocusReset) {\r\n                    _this.resetFocus(_this._currentRestrictType === RestrictFocusType.RestrictedFocusFirst);\r\n                }\r\n            }, 100);\r\n        }\r\n    };\r\n    FocusManager.prototype.limitFocusWithin = function (limitType) {\r\n        var _this = this;\r\n        if (this._isFocusLimited !== Interfaces_1.Types.LimitFocusType.Unlimited ||\r\n            (limitType !== Interfaces_1.Types.LimitFocusType.Limited &&\r\n                limitType !== Interfaces_1.Types.LimitFocusType.Accessible)) {\r\n            return;\r\n        }\r\n        this._isFocusLimited = limitType;\r\n        Object.keys(this._myFocusableComponentIds).forEach(function (componentId) {\r\n            var storedComponent = FocusManager._allFocusableComponents[componentId];\r\n            if (limitType === Interfaces_1.Types.LimitFocusType.Accessible) {\r\n                storedComponent.limitedCountAccessible++;\r\n            }\r\n            else if (limitType === Interfaces_1.Types.LimitFocusType.Limited) {\r\n                storedComponent.limitedCount++;\r\n            }\r\n            _this._updateComponentFocusRestriction(storedComponent);\r\n        });\r\n    };\r\n    FocusManager.prototype.removeFocusLimitation = function () {\r\n        var _this = this;\r\n        if (this._isFocusLimited === Interfaces_1.Types.LimitFocusType.Unlimited) {\r\n            return;\r\n        }\r\n        Object.keys(this._myFocusableComponentIds).forEach(function (componentId) {\r\n            var storedComponent = FocusManager._allFocusableComponents[componentId];\r\n            if (_this._isFocusLimited === Interfaces_1.Types.LimitFocusType.Accessible) {\r\n                storedComponent.limitedCountAccessible--;\r\n            }\r\n            else if (_this._isFocusLimited === Interfaces_1.Types.LimitFocusType.Limited) {\r\n                storedComponent.limitedCount--;\r\n            }\r\n            _this._updateComponentFocusRestriction(storedComponent);\r\n        });\r\n        this._isFocusLimited = Interfaces_1.Types.LimitFocusType.Unlimited;\r\n    };\r\n    FocusManager.prototype.release = function () {\r\n        this.removeFocusRestriction();\r\n        this.removeFocusLimitation();\r\n    };\r\n    FocusManager.subscribe = function (component, callback) {\r\n        var storedComponent = FocusManager._getStoredComponent(component);\r\n        if (storedComponent) {\r\n            if (!storedComponent.callbacks) {\r\n                storedComponent.callbacks = [];\r\n            }\r\n            storedComponent.callbacks.push(callback);\r\n        }\r\n    };\r\n    FocusManager.unsubscribe = function (component, callback) {\r\n        var storedComponent = FocusManager._getStoredComponent(component);\r\n        if (storedComponent && storedComponent.callbacks) {\r\n            storedComponent.callbacks = storedComponent.callbacks.filter(function (cb) { return cb !== callback; });\r\n        }\r\n    };\r\n    FocusManager.prototype.setRestrictionStateCallback = function (callback) {\r\n        this._restrictionStateCallback = callback;\r\n    };\r\n    FocusManager.isComponentFocusRestrictedOrLimited = function (component) {\r\n        var storedComponent = FocusManager._getStoredComponent(component);\r\n        return !!storedComponent &&\r\n            (storedComponent.restricted || storedComponent.limitedCount > 0 || storedComponent.limitedCountAccessible > 0);\r\n    };\r\n    FocusManager.getCurrentFocusedComponent = function () {\r\n        return FocusManager._currentFocusedComponent ? FocusManager._currentFocusedComponent.id : undefined;\r\n    };\r\n    FocusManager._getStoredComponent = function (component) {\r\n        var componentId = component.focusableComponentId;\r\n        if (componentId) {\r\n            return FocusManager._allFocusableComponents[componentId];\r\n        }\r\n        return undefined;\r\n    };\r\n    FocusManager._callFocusableComponentStateChangeCallbacks = function (storedComponent, restrictedOrLimited) {\r\n        if (!storedComponent.callbacks) {\r\n            return;\r\n        }\r\n        storedComponent.callbacks.forEach(function (callback) {\r\n            callback.call(storedComponent.component, restrictedOrLimited);\r\n        });\r\n    };\r\n    FocusManager.prototype._removeFocusRestriction = function () {\r\n        var _this = this;\r\n        Object.keys(FocusManager._allFocusableComponents).forEach(function (componentId) {\r\n            var storedComponent = FocusManager._allFocusableComponents[componentId];\r\n            storedComponent.restricted = false;\r\n            _this._updateComponentFocusRestriction(storedComponent);\r\n        });\r\n    };\r\n    FocusManager._clearRestoreRestrictionTimeout = function () {\r\n        if (FocusManager._restoreRestrictionTimer) {\r\n            Timers_1.default.clearTimeout(FocusManager._restoreRestrictionTimer);\r\n            FocusManager._restoreRestrictionTimer = undefined;\r\n            FocusManager._pendingPrevFocusedComponent = undefined;\r\n        }\r\n    };\r\n    FocusManager._restrictionStack = [];\r\n    FocusManager._allFocusableComponents = {};\r\n    FocusManager._skipFocusCheck = false;\r\n    return FocusManager;\r\n}());\r\nexports.FocusManager = FocusManager;\r\n// A mixin for the focusable elements, to tell the views that\r\n// they exist and should be accounted during the focus restriction.\r\n//\r\n// isConditionallyFocusable is an optional callback which will be\r\n// called for componentDidMount() or for UNSAFE_componentWillUpdate() to\r\n// determine if the component is actually focusable.\r\n//\r\n// accessibleOnly is true for components that support just being focused\r\n// by screen readers.\r\n// By default components support both screen reader and keyboard focusing.\r\nfunction applyFocusableComponentMixin(Component, isConditionallyFocusable, accessibleOnly) {\r\n    if (accessibleOnly === void 0) { accessibleOnly = false; }\r\n    var contextTypes = Component.contextTypes || {};\r\n    contextTypes.focusManager = PropTypes.object;\r\n    Component.contextTypes = contextTypes;\r\n    inheritMethod('componentDidMount', function (focusManager) {\r\n        if (!isConditionallyFocusable || isConditionallyFocusable.call(this)) {\r\n            focusManager.addFocusableComponent(this, accessibleOnly);\r\n        }\r\n    });\r\n    inheritMethod('componentWillUnmount', function (focusManager) {\r\n        focusManager.removeFocusableComponent(this);\r\n    });\r\n    inheritMethod('UNSAFE_componentWillUpdate', function (focusManager, origArgs) {\r\n        if (isConditionallyFocusable) {\r\n            var isFocusable = isConditionallyFocusable.apply(this, origArgs);\r\n            if (isFocusable && !this.focusableComponentId) {\r\n                focusManager.addFocusableComponent(this, accessibleOnly);\r\n            }\r\n            else if (!isFocusable && this.focusableComponentId) {\r\n                focusManager.removeFocusableComponent(this);\r\n            }\r\n        }\r\n    });\r\n    function inheritMethod(methodName, action) {\r\n        var origCallback = Component.prototype[methodName];\r\n        Component.prototype[methodName] = function () {\r\n            if (!isConditionallyFocusable || isConditionallyFocusable.call(this)) {\r\n                var focusManager = this._focusManager || (this.context && this.context.focusManager);\r\n                if (focusManager) {\r\n                    action.call(this, focusManager, arguments);\r\n                }\r\n                else {\r\n                    if (AppConfig_1.default.isDevelopmentMode()) {\r\n                        console.error('FocusableComponentMixin: context error!');\r\n                    }\r\n                }\r\n            }\r\n            if (origCallback) {\r\n                origCallback.apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n}\r\nexports.applyFocusableComponentMixin = applyFocusableComponentMixin;\r\nexports.default = FocusManager;\r\n"]},"metadata":{},"sourceType":"script"}