{"ast":null,"code":"\"use strict\";\n/**\r\n * executeTransition.tsx\r\n *\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n *\r\n * Provides a convenient API for applying a CSS transition to a DOM element and\r\n * notifying when the transition is complete.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeTransition = void 0;\n\nvar Timers_1 = require(\"../../common/utils/Timers\");\n\nvar _ = require(\"./../utils/lodashMini\"); // Convenient API for applying a CSS transition to a DOM element. Calls `done` when the transition is completed.\n\n\nfunction executeTransition(element, transitions, done) {\n  var longestDurationPlusDelay = 0;\n  var longestDurationProperty = '';\n  var cssTransitions = [];\n\n  _.each(transitions, function (transition) {\n    var property = transition.property;\n    var duration = transition.duration;\n    var timing = transition.timing === undefined ? 'linear' : transition.timing;\n    var delay = transition.delay === undefined ? 0 : transition.delay;\n    var from = transition.from;\n\n    if (duration + delay > longestDurationPlusDelay) {\n      longestDurationPlusDelay = duration + delay;\n      longestDurationProperty = property;\n    } // Initial state\n\n\n    element.style[property] = from; // Resolve styles. This is a trick to force the browser to refresh the\n    // computed styles. Without this, it won't pick up the new \"from\" value\n    // that we just set above.\n    // eslint-disable-next-line no-unused-expressions\n\n    getComputedStyle(element).opacity; // TODO: Cross-browser equivalent of 'transition' style (e.g. vendor prefixed).\n\n    cssTransitions.push(property + ' ' + duration + 'ms ' + timing + ' ' + delay + 'ms');\n  });\n\n  element.style.transition = cssTransitions.join(', '); // eslint-disable-next-line prefer-const\n\n  var finish;\n\n  var onTransitionEnd = function (ev) {\n    if (ev.target === element && ev.propertyName === longestDurationProperty) {\n      finish();\n    }\n  }; // TODO: Cross-browser equivalent of 'transitionEnd' event (e.g. vendor prefixed).\n\n\n  element.addEventListener('webkitTransitionEnd', onTransitionEnd);\n  element.addEventListener('transitionEnd', onTransitionEnd);\n  var timeoutId = 0;\n  var didFinish = false;\n\n  finish = function () {\n    if (!didFinish) {\n      Timers_1.default.clearTimeout(timeoutId); // Only complete the transition if we are ending the same transition it was initially set.\n      // There are cases where transitions may be overriden before the transition ends.\n\n      if (element.dataset.transitionId === timeoutId.toString()) {\n        // TODO: Cross-browser equivalent of 'transitionEnd' event (e.g. vendor prefixed).\n        element.removeEventListener('webkitTransitionEnd', onTransitionEnd);\n        element.removeEventListener('transitionEnd', onTransitionEnd);\n        delete element.dataset.transitionId;\n        element.style.transition = 'none';\n        didFinish = true;\n        done();\n      }\n    }\n  }; // Watchdog timeout for cases where transitionEnd event doesn't fire.\n\n\n  timeoutId = Timers_1.default.setTimeout(function () {\n    // If the item was removed from the DOM (which can happen if a\n    // rerender occurred), don't bother finishing. We don't want to do\n    // this in the transition event finish path because it's expensive\n    // and unnecessary in that case because the transition event\n    // implies that the element is still in the DOC\n    if (document.body.contains(element)) {\n      finish();\n    }\n  }, longestDurationPlusDelay + 10);\n  element.dataset.transitionId = timeoutId.toString(); // Set the \"to\" values.\n\n  _.each(transitions, function (transition) {\n    var property = transition.property;\n    var to = transition.to;\n    element.style[property] = to;\n  });\n}\n\nexports.executeTransition = executeTransition;\nexports.default = executeTransition;","map":{"version":3,"sources":["/Users/trungthang/webStreamGame/webStreamGame/node_modules/react-ult/dist/web/animated/executeTransition.js"],"names":["Object","defineProperty","exports","value","executeTransition","Timers_1","require","_","element","transitions","done","longestDurationPlusDelay","longestDurationProperty","cssTransitions","each","transition","property","duration","timing","undefined","delay","from","style","getComputedStyle","opacity","push","join","finish","onTransitionEnd","ev","target","propertyName","addEventListener","timeoutId","didFinish","default","clearTimeout","dataset","transitionId","toString","removeEventListener","setTimeout","document","body","contains","to"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/**\r\n * executeTransition.tsx\r\n *\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n *\r\n * Provides a convenient API for applying a CSS transition to a DOM element and\r\n * notifying when the transition is complete.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.executeTransition = void 0;\r\nvar Timers_1 = require(\"../../common/utils/Timers\");\r\nvar _ = require(\"./../utils/lodashMini\");\r\n// Convenient API for applying a CSS transition to a DOM element. Calls `done` when the transition is completed.\r\nfunction executeTransition(element, transitions, done) {\r\n    var longestDurationPlusDelay = 0;\r\n    var longestDurationProperty = '';\r\n    var cssTransitions = [];\r\n    _.each(transitions, function (transition) {\r\n        var property = transition.property;\r\n        var duration = transition.duration;\r\n        var timing = transition.timing === undefined ? 'linear' : transition.timing;\r\n        var delay = transition.delay === undefined ? 0 : transition.delay;\r\n        var from = transition.from;\r\n        if (duration + delay > longestDurationPlusDelay) {\r\n            longestDurationPlusDelay = duration + delay;\r\n            longestDurationProperty = property;\r\n        }\r\n        // Initial state\r\n        element.style[property] = from;\r\n        // Resolve styles. This is a trick to force the browser to refresh the\r\n        // computed styles. Without this, it won't pick up the new \"from\" value\r\n        // that we just set above.\r\n        // eslint-disable-next-line no-unused-expressions\r\n        getComputedStyle(element).opacity;\r\n        // TODO: Cross-browser equivalent of 'transition' style (e.g. vendor prefixed).\r\n        cssTransitions.push(property + ' ' + duration + 'ms ' + timing + ' ' + delay + 'ms');\r\n    });\r\n    element.style.transition = cssTransitions.join(', ');\r\n    // eslint-disable-next-line prefer-const\r\n    var finish;\r\n    var onTransitionEnd = function (ev) {\r\n        if (ev.target === element && ev.propertyName === longestDurationProperty) {\r\n            finish();\r\n        }\r\n    };\r\n    // TODO: Cross-browser equivalent of 'transitionEnd' event (e.g. vendor prefixed).\r\n    element.addEventListener('webkitTransitionEnd', onTransitionEnd);\r\n    element.addEventListener('transitionEnd', onTransitionEnd);\r\n    var timeoutId = 0;\r\n    var didFinish = false;\r\n    finish = function () {\r\n        if (!didFinish) {\r\n            Timers_1.default.clearTimeout(timeoutId);\r\n            // Only complete the transition if we are ending the same transition it was initially set.\r\n            // There are cases where transitions may be overriden before the transition ends.\r\n            if (element.dataset.transitionId === timeoutId.toString()) {\r\n                // TODO: Cross-browser equivalent of 'transitionEnd' event (e.g. vendor prefixed).\r\n                element.removeEventListener('webkitTransitionEnd', onTransitionEnd);\r\n                element.removeEventListener('transitionEnd', onTransitionEnd);\r\n                delete element.dataset.transitionId;\r\n                element.style.transition = 'none';\r\n                didFinish = true;\r\n                done();\r\n            }\r\n        }\r\n    };\r\n    // Watchdog timeout for cases where transitionEnd event doesn't fire.\r\n    timeoutId = Timers_1.default.setTimeout(function () {\r\n        // If the item was removed from the DOM (which can happen if a\r\n        // rerender occurred), don't bother finishing. We don't want to do\r\n        // this in the transition event finish path because it's expensive\r\n        // and unnecessary in that case because the transition event\r\n        // implies that the element is still in the DOC\r\n        if (document.body.contains(element)) {\r\n            finish();\r\n        }\r\n    }, longestDurationPlusDelay + 10);\r\n    element.dataset.transitionId = timeoutId.toString();\r\n    // Set the \"to\" values.\r\n    _.each(transitions, function (transition) {\r\n        var property = transition.property;\r\n        var to = transition.to;\r\n        element.style[property] = to;\r\n    });\r\n}\r\nexports.executeTransition = executeTransition;\r\nexports.default = executeTransition;\r\n"]},"metadata":{},"sourceType":"script"}