{"ast":null,"code":"\"use strict\";\n/**\r\n * GestureView.tsx\r\n *\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n *\r\n * Cross-platform parts of the implementation of the GestureView component.\r\n * It provides much of the standard work necessary to support combinations of\r\n * pinch-and-zoom, panning, single tap and double tap gestures.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GestureView = exports.GestureType = void 0;\n\nvar React = require(\"react\");\n\nvar assert_1 = require(\"../common/assert\");\n\nvar Interfaces_1 = require(\"../common/Interfaces\");\n\nvar Timers_1 = require(\"../common/utils/Timers\");\n\nvar GestureType;\n\n(function (GestureType) {\n  GestureType[GestureType[\"None\"] = 0] = \"None\";\n  GestureType[GestureType[\"MultiTouch\"] = 1] = \"MultiTouch\";\n  GestureType[GestureType[\"Pan\"] = 2] = \"Pan\";\n  GestureType[GestureType[\"PanVertical\"] = 3] = \"PanVertical\";\n  GestureType[GestureType[\"PanHorizontal\"] = 4] = \"PanHorizontal\";\n})(GestureType = exports.GestureType || (exports.GestureType = {})); // These threshold values were chosen empirically.\n\n\nvar _pinchZoomPixelThreshold = 3;\nvar _panPixelThreshold = 10;\nvar _tapDurationThreshold = 500;\nvar _longPressDurationThreshold = 750;\nvar _tapPixelThreshold = 4;\nvar _doubleTapDurationThreshold = 250;\nvar _doubleTapPixelThreshold = 20;\n\nvar GestureView =\n/** @class */\nfunction (_super) {\n  __extends(GestureView, _super);\n\n  function GestureView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // State for tracking move gestures (pinch/zoom or pan)\n\n\n    _this._pendingGestureType = GestureType.None; // Skip ability for next tap to work around some event issues\n\n    _this._shouldSkipNextTap = false; // Protected only as a hack for supporting keyboard nav clicking from native-common/GestureView\n\n    _this._sendTapEvent = function (tapEvent) {\n      // we need to skip tap after succesfull pan event\n      // mouse up would otherwise trigger both pan & tap\n      if (_this._shouldSkipNextTap) {\n        _this._shouldSkipNextTap = false;\n        return;\n      }\n\n      var button = GestureView._toMouseButton(tapEvent);\n\n      if (button === 2) {\n        // Always handle secondary button, even if context menu is not set - it shouldn't trigger onTap.\n        if (_this.props.onContextMenu) {\n          _this.props.onContextMenu(tapEvent);\n        }\n      } else if (_this.props.onTap) {\n        _this.props.onTap(tapEvent);\n      }\n    };\n\n    return _this;\n  }\n\n  GestureView.prototype.componentWillUnmount = function () {\n    // Dispose of timer before the component goes away.\n    this._cancelDoubleTapTimer();\n  }; // Returns true if we care about trapping/tracking the event\n\n\n  GestureView.prototype._onTouchSeriesStart = function (event) {\n    this._lastGestureStartEvent = event; // If we're trying to detect a tap, set this as the responder immediately.\n\n    if (this.props.onTap || this.props.onDoubleTap || this.props.onLongPress || this.props.onContextMenu) {\n      if (this.props.onLongPress) {\n        var gsState = this._touchEventToTapGestureState(event);\n\n        this._startLongPressTimer(gsState);\n      }\n\n      return true;\n    }\n\n    return false;\n  }; // Returns true if we care about trapping/tracking the event\n\n\n  GestureView.prototype._onTouchChange = function (event, gestureState) {\n    if (!this._lastGestureStartEvent) {\n      this._lastGestureStartEvent = event;\n    } // If this is the first movement we've seen, try to match it against\n    // the various move gestures that we're looking for.\n\n\n    var initializeFromEvent = false;\n\n    if (this._pendingGestureType === GestureType.None) {\n      this._pendingGestureType = this._detectMoveGesture(event, gestureState);\n      initializeFromEvent = true;\n    }\n\n    if (this._pendingGestureType === GestureType.MultiTouch) {\n      this._setPendingGestureState(this._sendMultiTouchEvents(event, gestureState, initializeFromEvent, false));\n\n      return true;\n    } else if (this._pendingGestureType === GestureType.Pan || this._pendingGestureType === GestureType.PanVertical || this._pendingGestureType === GestureType.PanHorizontal) {\n      var spEvent = this._touchEventToTapGestureState(event);\n\n      this._setPendingGestureState(this._sendPanEvent(spEvent, gestureState, this._pendingGestureType, initializeFromEvent, false));\n\n      return true;\n    }\n\n    return false;\n  };\n\n  GestureView.prototype._onTouchSeriesFinished = function (touchEvent, gestureState) {\n    // Can't possibly be a long press if the touch ended.\n    this._cancelLongPressTimer(); // Close out any of the pending move gestures.\n\n\n    if (this._pendingGestureType === GestureType.MultiTouch) {\n      this._sendMultiTouchEvents(touchEvent, gestureState, false, true);\n\n      this._pendingGestureState = undefined;\n      this._pendingGestureType = GestureType.None;\n    } else if (this._pendingGestureType === GestureType.Pan || this._pendingGestureType === GestureType.PanVertical || this._pendingGestureType === GestureType.PanHorizontal) {\n      var spEvent = this._touchEventToTapGestureState(touchEvent);\n\n      this._sendPanEvent(spEvent, gestureState, this._pendingGestureType, false, true);\n\n      this._pendingGestureState = undefined;\n      this._pendingGestureType = GestureType.None;\n    } else if (this._isTap(touchEvent)) {\n      var tapGestureState = this._touchEventToTapGestureState(touchEvent);\n\n      if (!this.props.onDoubleTap) {\n        // If there is no double-tap handler, we can invoke the tap handler immediately.\n        this._sendTapEvent(tapGestureState);\n      } else if (this._isDoubleTap(tapGestureState)) {\n        // This is a double-tap, so swallow the previous single tap.\n        this._cancelDoubleTapTimer();\n\n        this._sendDoubleTapEvent(tapGestureState);\n      } else {\n        // This wasn't a double-tap. Report any previous single tap and start the double-tap\n        // timer so we can determine whether the current tap is a single or double.\n        this._reportDelayedTap();\n\n        this._startDoubleTapTimer(tapGestureState);\n      }\n    } else {\n      this._reportDelayedTap();\n\n      this._cancelDoubleTapTimer();\n    }\n  };\n\n  GestureView.prototype._skipNextTap = function () {\n    this._shouldSkipNextTap = true;\n  };\n\n  GestureView.prototype._setPendingGestureState = function (gestureState) {\n    this._reportDelayedTap();\n\n    this._cancelDoubleTapTimer();\n\n    this._cancelLongPressTimer();\n\n    this._pendingGestureState = gestureState;\n  };\n\n  GestureView.prototype._detectMoveGesture = function (e, gestureState) {\n    if (this._shouldRespondToPinchZoom(e) || this._shouldRespondToRotate(e)) {\n      return GestureType.MultiTouch;\n    } else if (this._shouldRespondToPan(gestureState)) {\n      return GestureType.Pan;\n    } else if (this._shouldRespondToPanVertical(gestureState)) {\n      return GestureType.PanVertical;\n    } else if (this._shouldRespondToPanHorizontal(gestureState)) {\n      return GestureType.PanHorizontal;\n    }\n\n    return GestureType.None;\n  }; // Determines whether a touch event constitutes a tap. The \"finger up\"\n  // event must be within a certain distance and within a certain time\n  // from where the \"finger down\" event occurred.\n\n\n  GestureView.prototype._isTap = function (e) {\n    if (!this._lastGestureStartEvent) {\n      return false;\n    }\n\n    var initialTimeStamp = this._getEventTimestamp(this._lastGestureStartEvent);\n\n    var initialPageX = this._lastGestureStartEvent.pageX;\n    var initialPageY = this._lastGestureStartEvent.pageY;\n\n    var timeStamp = this._getEventTimestamp(e);\n\n    return timeStamp - initialTimeStamp <= _tapDurationThreshold && this._calcDistance(initialPageX - e.pageX, initialPageY - e.pageY) <= _tapPixelThreshold;\n  }; // This method assumes that the caller has already determined that two\n  // taps have been detected in a row with no intervening gestures. It\n  // is responsible for determining if they occurred within close proximity\n  // and within a certain threshold of time.\n\n\n  GestureView.prototype._isDoubleTap = function (e) {\n    if (!this._lastTapEvent) {\n      return false;\n    }\n\n    return e.timeStamp - this._lastTapEvent.timeStamp <= _doubleTapDurationThreshold && this._calcDistance(this._lastTapEvent.pageX - e.pageX, this._lastTapEvent.pageY - e.pageY) <= _doubleTapPixelThreshold;\n  }; // Starts a timer that reports a previous tap if it's not canceled by a subsequent gesture.\n\n\n  GestureView.prototype._startDoubleTapTimer = function (e) {\n    var _this = this;\n\n    this._lastTapEvent = e;\n    this._doubleTapTimer = Timers_1.default.setTimeout(function () {\n      _this._reportDelayedTap();\n\n      _this._doubleTapTimer = undefined;\n    }, _doubleTapDurationThreshold);\n  }; // Cancels any pending double-tap timer.\n\n\n  GestureView.prototype._cancelDoubleTapTimer = function () {\n    if (this._doubleTapTimer) {\n      Timers_1.default.clearTimeout(this._doubleTapTimer);\n      this._doubleTapTimer = undefined;\n    }\n  };\n\n  GestureView.prototype._startLongPressTimer = function (gsState, isDefinitelyMouse) {\n    var _this = this;\n\n    if (isDefinitelyMouse === void 0) {\n      isDefinitelyMouse = false;\n    }\n\n    if (this._pendingLongPressEvent) {\n      return;\n    }\n\n    this._pendingLongPressEvent = gsState;\n    this._longPressTimer = Timers_1.default.setTimeout(function () {\n      _this._reportLongPress();\n\n      _this._longPressTimer = undefined;\n    }, _longPressDurationThreshold);\n  };\n\n  GestureView.prototype._reportLongPress = function () {\n    if (!this._pendingLongPressEvent) {\n      return;\n    }\n\n    if (this.props.onLongPress) {\n      this.props.onLongPress(this._pendingLongPressEvent);\n    }\n\n    this._pendingLongPressEvent = undefined;\n  };\n\n  GestureView.prototype._cancelLongPressTimer = function () {\n    if (this._longPressTimer) {\n      Timers_1.default.clearTimeout(this._longPressTimer);\n      this._longPressTimer = undefined;\n    }\n\n    this._pendingLongPressEvent = undefined;\n  }; // If there was a previous tap recorded but we haven't yet reported it because we were\n  // waiting for a potential second tap, report it now.\n\n\n  GestureView.prototype._reportDelayedTap = function () {\n    if (this._lastTapEvent && this.props.onTap) {\n      this._sendTapEvent(this._lastTapEvent);\n\n      this._lastTapEvent = undefined;\n    }\n  };\n\n  GestureView.prototype._clearLastTap = function () {\n    this._lastTapEvent = undefined;\n  };\n\n  GestureView._isActuallyMouseEvent = function (e) {\n    if (!e) {\n      return false;\n    }\n\n    var nativeEvent = e;\n\n    if (nativeEvent.button !== undefined) {\n      return true;\n    } else if (nativeEvent.isRightButton || nativeEvent.IsRightButton) {\n      return true;\n    } else if (nativeEvent.isMiddleButton || nativeEvent.IsMiddleButton) {\n      return true;\n    }\n\n    return false;\n  };\n\n  GestureView.prototype._shouldRespondToPinchZoom = function (e) {\n    if (!this.props.onPinchZoom) {\n      return false;\n    } // Do we see two touches?\n\n\n    if (!e.touches || e.touches.length !== 2) {\n      return false;\n    } // Has the user started to pinch or zoom?\n\n\n    var distance = this._calcDistance(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);\n\n    if (distance >= _pinchZoomPixelThreshold) {\n      return true;\n    }\n\n    return false;\n  };\n\n  GestureView.prototype._shouldRespondToRotate = function (e) {\n    if (!this.props.onRotate) {\n      return false;\n    } // Do we see two touches?\n\n\n    if (!e.touches || e.touches.length !== 2) {\n      return false;\n    }\n\n    return true;\n  };\n\n  GestureView.prototype._shouldRespondToPan = function (gestureState) {\n    if (!this.props.onPan) {\n      return false;\n    } // Has the user started to pan?\n\n\n    var panThreshold = this.props.panPixelThreshold !== undefined && this.props.panPixelThreshold > 0 ? this.props.panPixelThreshold : _panPixelThreshold;\n    return this._calcDistance(gestureState.dx, gestureState.dy) >= panThreshold;\n  };\n\n  GestureView.prototype._shouldRespondToPanVertical = function (gestureState) {\n    if (!this.props.onPanVertical) {\n      return false;\n    } // Has the user started to pan?\n\n\n    var panThreshold = this.props.panPixelThreshold !== undefined && this.props.panPixelThreshold > 0 ? this.props.panPixelThreshold : _panPixelThreshold;\n    var isPan = Math.abs(gestureState.dy) >= panThreshold;\n\n    if (isPan && this.props.preferredPan === Interfaces_1.Types.PreferredPanGesture.Horizontal) {\n      return Math.abs(gestureState.dy) > Math.abs(gestureState.dx * this._getPreferredPanRatio());\n    }\n\n    return isPan;\n  };\n\n  GestureView.prototype._shouldRespondToPanHorizontal = function (gestureState) {\n    if (!this.props.onPanHorizontal) {\n      return false;\n    } // Has the user started to pan?\n\n\n    var panThreshold = this.props.panPixelThreshold !== undefined && this.props.panPixelThreshold > 0 ? this.props.panPixelThreshold : _panPixelThreshold;\n    var isPan = Math.abs(gestureState.dx) >= panThreshold;\n\n    if (isPan && this.props.preferredPan === Interfaces_1.Types.PreferredPanGesture.Vertical) {\n      return Math.abs(gestureState.dx) > Math.abs(gestureState.dy * this._getPreferredPanRatio());\n    }\n\n    return isPan;\n  };\n\n  GestureView.prototype._calcDistance = function (dx, dy) {\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  GestureView.prototype._calcAngle = function (touches) {\n    var a = touches[0];\n    var b = touches[1];\n\n    var degrees = this._radiansToDegrees(Math.atan2(b.pageY - a.pageY, b.pageX - a.pageX));\n\n    if (degrees < 0) {\n      degrees += 360;\n    }\n\n    return degrees;\n  };\n\n  GestureView.prototype._radiansToDegrees = function (rad) {\n    return rad * 180 / Math.PI;\n  };\n\n  GestureView.prototype._sendMultiTouchEvents = function (e, gestureState, initializeFromEvent, isComplete) {\n    var p = this._pendingGestureState;\n    var multiTouchEvent; // If the user lifted up one or both fingers, the multitouch gesture\n    // is halted. Just return the existing gesture state.\n\n    if (!e.touches || e.touches.length !== 2) {\n      multiTouchEvent = p;\n      p.isComplete = isComplete;\n    } else {\n      var centerPageX = (e.touches[0].pageX + e.touches[1].pageX) / 2;\n      var centerPageY = (e.touches[0].pageY + e.touches[1].pageY) / 2;\n      var centerClientX = (e.touches[0].locationX + e.touches[1].locationX) / 2;\n      var centerClientY = (e.touches[0].locationY + e.touches[1].locationY) / 2;\n      var width = Math.abs(e.touches[0].pageX - e.touches[1].pageX);\n      var height = Math.abs(e.touches[0].pageY - e.touches[1].pageY);\n\n      var distance = this._calcDistance(width, height);\n\n      var angle = this._calcAngle(e.touches);\n\n      var initialCenterPageX = initializeFromEvent ? centerPageX : p.initialCenterPageX;\n      var initialCenterPageY = initializeFromEvent ? centerPageY : p.initialCenterPageY;\n      var initialCenterClientX = initializeFromEvent ? centerClientX : p.initialCenterClientX;\n      var initialCenterClientY = initializeFromEvent ? centerClientY : p.initialCenterClientY;\n      var initialWidth = initializeFromEvent ? width : p.initialWidth;\n      var initialHeight = initializeFromEvent ? height : p.initialHeight;\n      var initialDistance = initializeFromEvent ? distance : p.initialDistance;\n      var initialAngle = initializeFromEvent ? angle : p.initialAngle;\n      var velocityX = initializeFromEvent ? 0 : gestureState.vx;\n      var velocityY = initializeFromEvent ? 0 : gestureState.vy;\n      multiTouchEvent = {\n        initialCenterPageX: initialCenterPageX,\n        initialCenterPageY: initialCenterPageY,\n        initialCenterClientX: initialCenterClientX,\n        initialCenterClientY: initialCenterClientY,\n        initialWidth: initialWidth,\n        initialHeight: initialHeight,\n        initialDistance: initialDistance,\n        initialAngle: initialAngle,\n        centerPageX: centerPageX,\n        centerPageY: centerPageY,\n        centerClientX: centerClientX,\n        centerClientY: centerClientY,\n        velocityX: velocityX,\n        velocityY: velocityY,\n        width: width,\n        height: height,\n        distance: distance,\n        angle: angle,\n        isComplete: isComplete,\n        timeStamp: e.timeStamp,\n        isTouch: !GestureView._isActuallyMouseEvent(e)\n      };\n    }\n\n    if (this.props.onPinchZoom) {\n      this.props.onPinchZoom(multiTouchEvent);\n    }\n\n    if (this.props.onRotate) {\n      this.props.onRotate(multiTouchEvent);\n    }\n\n    return multiTouchEvent;\n  };\n\n  GestureView.prototype._touchEventToTapGestureState = function (e) {\n    var pageX = e.pageX;\n    var pageY = e.pageY;\n    var clientX = e.locationX;\n    var clientY = e.locationY; // Grab the first touch. If the user adds additional touch events,\n    // we will ignore them. If we use e.pageX/Y, we will be using the average\n    // of the touches, so we'll see a discontinuity.\n\n    if (e.touches && e.touches.length > 0) {\n      pageX = e.touches[0].pageX;\n      pageY = e.touches[0].pageY;\n      clientX = e.touches[0].locationX;\n      clientY = e.touches[0].locationY;\n    }\n\n    return {\n      timeStamp: this._getEventTimestamp(e),\n      clientX: clientX,\n      clientY: clientY,\n      pageX: pageX,\n      pageY: pageY,\n      isTouch: !GestureView._isActuallyMouseEvent(e)\n    };\n  };\n\n  GestureView.prototype._mouseEventToTapGestureState = function (e) {\n    var xyOffset = this._getClientXYOffset();\n\n    return {\n      timeStamp: this._getEventTimestamp(e),\n      clientX: e.clientX - xyOffset.x,\n      clientY: e.clientY - xyOffset.y,\n      pageX: e.pageX || 0,\n      pageY: e.pageY || 0,\n      isTouch: false\n    };\n  };\n\n  GestureView.prototype._getClientXYOffset = function () {\n    return {\n      x: 0,\n      y: 0\n    };\n  };\n\n  GestureView.prototype._sendPanEvent = function (e, gestureState, gestureType, initializeFromEvent, isComplete) {\n    var state = this._pendingGestureState;\n    assert_1.default(this._lastGestureStartEvent, 'Gesture start event must not be null.');\n    var initialPageX = this._lastGestureStartEvent ? this._lastGestureStartEvent.pageX : initializeFromEvent ? e.pageX : state.initialPageX;\n    var initialPageY = this._lastGestureStartEvent ? this._lastGestureStartEvent.pageY : initializeFromEvent ? e.pageY : state.initialPageY;\n    var initialClientX = this._lastGestureStartEvent ? this._lastGestureStartEvent.locationX : initializeFromEvent ? e.clientX : state.initialClientX;\n    var initialClientY = this._lastGestureStartEvent ? this._lastGestureStartEvent.locationY : initializeFromEvent ? e.clientY : state.initialClientY;\n    var velocityX = initializeFromEvent ? 0 : gestureState.vx;\n    var velocityY = initializeFromEvent ? 0 : gestureState.vy;\n    var panEvent = {\n      initialPageX: initialPageX,\n      initialPageY: initialPageY,\n      initialClientX: initialClientX,\n      initialClientY: initialClientY,\n      pageX: e.pageX,\n      pageY: e.pageY,\n      clientX: e.clientX,\n      clientY: e.clientY,\n      velocityX: velocityX,\n      velocityY: velocityY,\n      isComplete: isComplete,\n      timeStamp: e.timeStamp,\n      isTouch: !GestureView._isActuallyMouseEvent(this._lastGestureStartEvent)\n    };\n\n    switch (gestureType) {\n      case GestureType.Pan:\n        if (this.props.onPan) {\n          this.props.onPan(panEvent);\n        }\n\n        break;\n\n      case GestureType.PanVertical:\n        if (this.props.onPanVertical) {\n          this.props.onPanVertical(panEvent);\n        }\n\n        break;\n\n      case GestureType.PanHorizontal:\n        if (this.props.onPanHorizontal) {\n          this.props.onPanHorizontal(panEvent);\n        }\n\n        break;\n\n      default: // do nothing;\n\n    }\n\n    return panEvent;\n  };\n\n  GestureView._toMouseButton = function (nativeEvent) {\n    if (nativeEvent.button !== undefined) {\n      return nativeEvent.button;\n    } else if (nativeEvent.isRightButton || nativeEvent.IsRightButton) {\n      return 2;\n    } else if (nativeEvent.isMiddleButton || nativeEvent.IsMiddleButton) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  GestureView.prototype._sendDoubleTapEvent = function (e) {\n    // If user did a double click with different mouse buttons, eg. left (50ms) right\n    // both clicks need to be registered as separate events.\n    var lastButton = GestureView._toMouseButton(this._lastTapEvent);\n\n    var button = GestureView._toMouseButton(e);\n\n    if (lastButton !== button || button === 2) {\n      this._sendTapEvent(this._lastTapEvent);\n\n      return;\n    }\n\n    if (this.props.onDoubleTap) {\n      this.props.onDoubleTap(e);\n    }\n\n    this._lastTapEvent = undefined;\n  };\n\n  return GestureView;\n}(React.Component);\n\nexports.GestureView = GestureView;\nexports.default = GestureView;","map":{"version":3,"sources":["/Users/dangthang/Desktop/webStreamGame/node_modules/react-ult/dist/common/GestureView.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__","constructor","create","defineProperty","exports","value","GestureView","GestureType","React","require","assert_1","Interfaces_1","Timers_1","_pinchZoomPixelThreshold","_panPixelThreshold","_tapDurationThreshold","_longPressDurationThreshold","_tapPixelThreshold","_doubleTapDurationThreshold","_doubleTapPixelThreshold","_super","_this","apply","arguments","_pendingGestureType","None","_shouldSkipNextTap","_sendTapEvent","tapEvent","button","_toMouseButton","props","onContextMenu","onTap","componentWillUnmount","_cancelDoubleTapTimer","_onTouchSeriesStart","event","_lastGestureStartEvent","onDoubleTap","onLongPress","gsState","_touchEventToTapGestureState","_startLongPressTimer","_onTouchChange","gestureState","initializeFromEvent","_detectMoveGesture","MultiTouch","_setPendingGestureState","_sendMultiTouchEvents","Pan","PanVertical","PanHorizontal","spEvent","_sendPanEvent","_onTouchSeriesFinished","touchEvent","_cancelLongPressTimer","_pendingGestureState","undefined","_isTap","tapGestureState","_isDoubleTap","_sendDoubleTapEvent","_reportDelayedTap","_startDoubleTapTimer","_skipNextTap","e","_shouldRespondToPinchZoom","_shouldRespondToRotate","_shouldRespondToPan","_shouldRespondToPanVertical","_shouldRespondToPanHorizontal","initialTimeStamp","_getEventTimestamp","initialPageX","pageX","initialPageY","pageY","timeStamp","_calcDistance","_lastTapEvent","_doubleTapTimer","default","setTimeout","clearTimeout","isDefinitelyMouse","_pendingLongPressEvent","_longPressTimer","_reportLongPress","_clearLastTap","_isActuallyMouseEvent","nativeEvent","isRightButton","IsRightButton","isMiddleButton","IsMiddleButton","onPinchZoom","touches","length","distance","onRotate","onPan","panThreshold","panPixelThreshold","dx","dy","onPanVertical","isPan","Math","abs","preferredPan","Types","PreferredPanGesture","Horizontal","_getPreferredPanRatio","onPanHorizontal","Vertical","sqrt","_calcAngle","a","degrees","_radiansToDegrees","atan2","rad","PI","isComplete","multiTouchEvent","centerPageX","centerPageY","centerClientX","locationX","centerClientY","locationY","width","height","angle","initialCenterPageX","initialCenterPageY","initialCenterClientX","initialCenterClientY","initialWidth","initialHeight","initialDistance","initialAngle","velocityX","vx","velocityY","vy","isTouch","clientX","clientY","_mouseEventToTapGestureState","xyOffset","_getClientXYOffset","x","y","gestureType","state","initialClientX","initialClientY","panEvent","lastButton","Component"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/**\r\n * GestureView.tsx\r\n *\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT license.\r\n *\r\n * Cross-platform parts of the implementation of the GestureView component.\r\n * It provides much of the standard work necessary to support combinations of\r\n * pinch-and-zoom, panning, single tap and double tap gestures.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GestureView = exports.GestureType = void 0;\r\nvar React = require(\"react\");\r\nvar assert_1 = require(\"../common/assert\");\r\nvar Interfaces_1 = require(\"../common/Interfaces\");\r\nvar Timers_1 = require(\"../common/utils/Timers\");\r\nvar GestureType;\r\n(function (GestureType) {\r\n    GestureType[GestureType[\"None\"] = 0] = \"None\";\r\n    GestureType[GestureType[\"MultiTouch\"] = 1] = \"MultiTouch\";\r\n    GestureType[GestureType[\"Pan\"] = 2] = \"Pan\";\r\n    GestureType[GestureType[\"PanVertical\"] = 3] = \"PanVertical\";\r\n    GestureType[GestureType[\"PanHorizontal\"] = 4] = \"PanHorizontal\";\r\n})(GestureType = exports.GestureType || (exports.GestureType = {}));\r\n// These threshold values were chosen empirically.\r\nvar _pinchZoomPixelThreshold = 3;\r\nvar _panPixelThreshold = 10;\r\nvar _tapDurationThreshold = 500;\r\nvar _longPressDurationThreshold = 750;\r\nvar _tapPixelThreshold = 4;\r\nvar _doubleTapDurationThreshold = 250;\r\nvar _doubleTapPixelThreshold = 20;\r\nvar GestureView = /** @class */ (function (_super) {\r\n    __extends(GestureView, _super);\r\n    function GestureView() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        // State for tracking move gestures (pinch/zoom or pan)\r\n        _this._pendingGestureType = GestureType.None;\r\n        // Skip ability for next tap to work around some event issues\r\n        _this._shouldSkipNextTap = false;\r\n        // Protected only as a hack for supporting keyboard nav clicking from native-common/GestureView\r\n        _this._sendTapEvent = function (tapEvent) {\r\n            // we need to skip tap after succesfull pan event\r\n            // mouse up would otherwise trigger both pan & tap\r\n            if (_this._shouldSkipNextTap) {\r\n                _this._shouldSkipNextTap = false;\r\n                return;\r\n            }\r\n            var button = GestureView._toMouseButton(tapEvent);\r\n            if (button === 2) {\r\n                // Always handle secondary button, even if context menu is not set - it shouldn't trigger onTap.\r\n                if (_this.props.onContextMenu) {\r\n                    _this.props.onContextMenu(tapEvent);\r\n                }\r\n            }\r\n            else if (_this.props.onTap) {\r\n                _this.props.onTap(tapEvent);\r\n            }\r\n        };\r\n        return _this;\r\n    }\r\n    GestureView.prototype.componentWillUnmount = function () {\r\n        // Dispose of timer before the component goes away.\r\n        this._cancelDoubleTapTimer();\r\n    };\r\n    // Returns true if we care about trapping/tracking the event\r\n    GestureView.prototype._onTouchSeriesStart = function (event) {\r\n        this._lastGestureStartEvent = event;\r\n        // If we're trying to detect a tap, set this as the responder immediately.\r\n        if (this.props.onTap || this.props.onDoubleTap || this.props.onLongPress || this.props.onContextMenu) {\r\n            if (this.props.onLongPress) {\r\n                var gsState = this._touchEventToTapGestureState(event);\r\n                this._startLongPressTimer(gsState);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    // Returns true if we care about trapping/tracking the event\r\n    GestureView.prototype._onTouchChange = function (event, gestureState) {\r\n        if (!this._lastGestureStartEvent) {\r\n            this._lastGestureStartEvent = event;\r\n        }\r\n        // If this is the first movement we've seen, try to match it against\r\n        // the various move gestures that we're looking for.\r\n        var initializeFromEvent = false;\r\n        if (this._pendingGestureType === GestureType.None) {\r\n            this._pendingGestureType = this._detectMoveGesture(event, gestureState);\r\n            initializeFromEvent = true;\r\n        }\r\n        if (this._pendingGestureType === GestureType.MultiTouch) {\r\n            this._setPendingGestureState(this._sendMultiTouchEvents(event, gestureState, initializeFromEvent, false));\r\n            return true;\r\n        }\r\n        else if (this._pendingGestureType === GestureType.Pan ||\r\n            this._pendingGestureType === GestureType.PanVertical ||\r\n            this._pendingGestureType === GestureType.PanHorizontal) {\r\n            var spEvent = this._touchEventToTapGestureState(event);\r\n            this._setPendingGestureState(this._sendPanEvent(spEvent, gestureState, this._pendingGestureType, initializeFromEvent, false));\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    GestureView.prototype._onTouchSeriesFinished = function (touchEvent, gestureState) {\r\n        // Can't possibly be a long press if the touch ended.\r\n        this._cancelLongPressTimer();\r\n        // Close out any of the pending move gestures.\r\n        if (this._pendingGestureType === GestureType.MultiTouch) {\r\n            this._sendMultiTouchEvents(touchEvent, gestureState, false, true);\r\n            this._pendingGestureState = undefined;\r\n            this._pendingGestureType = GestureType.None;\r\n        }\r\n        else if (this._pendingGestureType === GestureType.Pan ||\r\n            this._pendingGestureType === GestureType.PanVertical ||\r\n            this._pendingGestureType === GestureType.PanHorizontal) {\r\n            var spEvent = this._touchEventToTapGestureState(touchEvent);\r\n            this._sendPanEvent(spEvent, gestureState, this._pendingGestureType, false, true);\r\n            this._pendingGestureState = undefined;\r\n            this._pendingGestureType = GestureType.None;\r\n        }\r\n        else if (this._isTap(touchEvent)) {\r\n            var tapGestureState = this._touchEventToTapGestureState(touchEvent);\r\n            if (!this.props.onDoubleTap) {\r\n                // If there is no double-tap handler, we can invoke the tap handler immediately.\r\n                this._sendTapEvent(tapGestureState);\r\n            }\r\n            else if (this._isDoubleTap(tapGestureState)) {\r\n                // This is a double-tap, so swallow the previous single tap.\r\n                this._cancelDoubleTapTimer();\r\n                this._sendDoubleTapEvent(tapGestureState);\r\n            }\r\n            else {\r\n                // This wasn't a double-tap. Report any previous single tap and start the double-tap\r\n                // timer so we can determine whether the current tap is a single or double.\r\n                this._reportDelayedTap();\r\n                this._startDoubleTapTimer(tapGestureState);\r\n            }\r\n        }\r\n        else {\r\n            this._reportDelayedTap();\r\n            this._cancelDoubleTapTimer();\r\n        }\r\n    };\r\n    GestureView.prototype._skipNextTap = function () {\r\n        this._shouldSkipNextTap = true;\r\n    };\r\n    GestureView.prototype._setPendingGestureState = function (gestureState) {\r\n        this._reportDelayedTap();\r\n        this._cancelDoubleTapTimer();\r\n        this._cancelLongPressTimer();\r\n        this._pendingGestureState = gestureState;\r\n    };\r\n    GestureView.prototype._detectMoveGesture = function (e, gestureState) {\r\n        if (this._shouldRespondToPinchZoom(e) || this._shouldRespondToRotate(e)) {\r\n            return GestureType.MultiTouch;\r\n        }\r\n        else if (this._shouldRespondToPan(gestureState)) {\r\n            return GestureType.Pan;\r\n        }\r\n        else if (this._shouldRespondToPanVertical(gestureState)) {\r\n            return GestureType.PanVertical;\r\n        }\r\n        else if (this._shouldRespondToPanHorizontal(gestureState)) {\r\n            return GestureType.PanHorizontal;\r\n        }\r\n        return GestureType.None;\r\n    };\r\n    // Determines whether a touch event constitutes a tap. The \"finger up\"\r\n    // event must be within a certain distance and within a certain time\r\n    // from where the \"finger down\" event occurred.\r\n    GestureView.prototype._isTap = function (e) {\r\n        if (!this._lastGestureStartEvent) {\r\n            return false;\r\n        }\r\n        var initialTimeStamp = this._getEventTimestamp(this._lastGestureStartEvent);\r\n        var initialPageX = this._lastGestureStartEvent.pageX;\r\n        var initialPageY = this._lastGestureStartEvent.pageY;\r\n        var timeStamp = this._getEventTimestamp(e);\r\n        return (timeStamp - initialTimeStamp <= _tapDurationThreshold &&\r\n            this._calcDistance(initialPageX - e.pageX, initialPageY - e.pageY) <= _tapPixelThreshold);\r\n    };\r\n    // This method assumes that the caller has already determined that two\r\n    // taps have been detected in a row with no intervening gestures. It\r\n    // is responsible for determining if they occurred within close proximity\r\n    // and within a certain threshold of time.\r\n    GestureView.prototype._isDoubleTap = function (e) {\r\n        if (!this._lastTapEvent) {\r\n            return false;\r\n        }\r\n        return (e.timeStamp - this._lastTapEvent.timeStamp <= _doubleTapDurationThreshold &&\r\n            this._calcDistance(this._lastTapEvent.pageX - e.pageX, this._lastTapEvent.pageY - e.pageY) <= _doubleTapPixelThreshold);\r\n    };\r\n    // Starts a timer that reports a previous tap if it's not canceled by a subsequent gesture.\r\n    GestureView.prototype._startDoubleTapTimer = function (e) {\r\n        var _this = this;\r\n        this._lastTapEvent = e;\r\n        this._doubleTapTimer = Timers_1.default.setTimeout(function () {\r\n            _this._reportDelayedTap();\r\n            _this._doubleTapTimer = undefined;\r\n        }, _doubleTapDurationThreshold);\r\n    };\r\n    // Cancels any pending double-tap timer.\r\n    GestureView.prototype._cancelDoubleTapTimer = function () {\r\n        if (this._doubleTapTimer) {\r\n            Timers_1.default.clearTimeout(this._doubleTapTimer);\r\n            this._doubleTapTimer = undefined;\r\n        }\r\n    };\r\n    GestureView.prototype._startLongPressTimer = function (gsState, isDefinitelyMouse) {\r\n        var _this = this;\r\n        if (isDefinitelyMouse === void 0) { isDefinitelyMouse = false; }\r\n        if (this._pendingLongPressEvent) {\r\n            return;\r\n        }\r\n        this._pendingLongPressEvent = gsState;\r\n        this._longPressTimer = Timers_1.default.setTimeout(function () {\r\n            _this._reportLongPress();\r\n            _this._longPressTimer = undefined;\r\n        }, _longPressDurationThreshold);\r\n    };\r\n    GestureView.prototype._reportLongPress = function () {\r\n        if (!this._pendingLongPressEvent) {\r\n            return;\r\n        }\r\n        if (this.props.onLongPress) {\r\n            this.props.onLongPress(this._pendingLongPressEvent);\r\n        }\r\n        this._pendingLongPressEvent = undefined;\r\n    };\r\n    GestureView.prototype._cancelLongPressTimer = function () {\r\n        if (this._longPressTimer) {\r\n            Timers_1.default.clearTimeout(this._longPressTimer);\r\n            this._longPressTimer = undefined;\r\n        }\r\n        this._pendingLongPressEvent = undefined;\r\n    };\r\n    // If there was a previous tap recorded but we haven't yet reported it because we were\r\n    // waiting for a potential second tap, report it now.\r\n    GestureView.prototype._reportDelayedTap = function () {\r\n        if (this._lastTapEvent && this.props.onTap) {\r\n            this._sendTapEvent(this._lastTapEvent);\r\n            this._lastTapEvent = undefined;\r\n        }\r\n    };\r\n    GestureView.prototype._clearLastTap = function () {\r\n        this._lastTapEvent = undefined;\r\n    };\r\n    GestureView._isActuallyMouseEvent = function (e) {\r\n        if (!e) {\r\n            return false;\r\n        }\r\n        var nativeEvent = e;\r\n        if (nativeEvent.button !== undefined) {\r\n            return true;\r\n        }\r\n        else if (nativeEvent.isRightButton || nativeEvent.IsRightButton) {\r\n            return true;\r\n        }\r\n        else if (nativeEvent.isMiddleButton || nativeEvent.IsMiddleButton) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    GestureView.prototype._shouldRespondToPinchZoom = function (e) {\r\n        if (!this.props.onPinchZoom) {\r\n            return false;\r\n        }\r\n        // Do we see two touches?\r\n        if (!e.touches || e.touches.length !== 2) {\r\n            return false;\r\n        }\r\n        // Has the user started to pinch or zoom?\r\n        var distance = this._calcDistance(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);\r\n        if (distance >= _pinchZoomPixelThreshold) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    GestureView.prototype._shouldRespondToRotate = function (e) {\r\n        if (!this.props.onRotate) {\r\n            return false;\r\n        }\r\n        // Do we see two touches?\r\n        if (!e.touches || e.touches.length !== 2) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    GestureView.prototype._shouldRespondToPan = function (gestureState) {\r\n        if (!this.props.onPan) {\r\n            return false;\r\n        }\r\n        // Has the user started to pan?\r\n        var panThreshold = (this.props.panPixelThreshold !== undefined && this.props.panPixelThreshold > 0) ?\r\n            this.props.panPixelThreshold : _panPixelThreshold;\r\n        return (this._calcDistance(gestureState.dx, gestureState.dy) >= panThreshold);\r\n    };\r\n    GestureView.prototype._shouldRespondToPanVertical = function (gestureState) {\r\n        if (!this.props.onPanVertical) {\r\n            return false;\r\n        }\r\n        // Has the user started to pan?\r\n        var panThreshold = (this.props.panPixelThreshold !== undefined && this.props.panPixelThreshold > 0) ?\r\n            this.props.panPixelThreshold : _panPixelThreshold;\r\n        var isPan = Math.abs(gestureState.dy) >= panThreshold;\r\n        if (isPan && this.props.preferredPan === Interfaces_1.Types.PreferredPanGesture.Horizontal) {\r\n            return Math.abs(gestureState.dy) > Math.abs(gestureState.dx * this._getPreferredPanRatio());\r\n        }\r\n        return isPan;\r\n    };\r\n    GestureView.prototype._shouldRespondToPanHorizontal = function (gestureState) {\r\n        if (!this.props.onPanHorizontal) {\r\n            return false;\r\n        }\r\n        // Has the user started to pan?\r\n        var panThreshold = (this.props.panPixelThreshold !== undefined && this.props.panPixelThreshold > 0) ?\r\n            this.props.panPixelThreshold : _panPixelThreshold;\r\n        var isPan = Math.abs(gestureState.dx) >= panThreshold;\r\n        if (isPan && this.props.preferredPan === Interfaces_1.Types.PreferredPanGesture.Vertical) {\r\n            return Math.abs(gestureState.dx) > Math.abs(gestureState.dy * this._getPreferredPanRatio());\r\n        }\r\n        return isPan;\r\n    };\r\n    GestureView.prototype._calcDistance = function (dx, dy) {\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    };\r\n    GestureView.prototype._calcAngle = function (touches) {\r\n        var a = touches[0];\r\n        var b = touches[1];\r\n        var degrees = this._radiansToDegrees(Math.atan2(b.pageY - a.pageY, b.pageX - a.pageX));\r\n        if (degrees < 0) {\r\n            degrees += 360;\r\n        }\r\n        return degrees;\r\n    };\r\n    GestureView.prototype._radiansToDegrees = function (rad) {\r\n        return rad * 180 / Math.PI;\r\n    };\r\n    GestureView.prototype._sendMultiTouchEvents = function (e, gestureState, initializeFromEvent, isComplete) {\r\n        var p = this._pendingGestureState;\r\n        var multiTouchEvent;\r\n        // If the user lifted up one or both fingers, the multitouch gesture\r\n        // is halted. Just return the existing gesture state.\r\n        if (!e.touches || e.touches.length !== 2) {\r\n            multiTouchEvent = p;\r\n            p.isComplete = isComplete;\r\n        }\r\n        else {\r\n            var centerPageX = (e.touches[0].pageX + e.touches[1].pageX) / 2;\r\n            var centerPageY = (e.touches[0].pageY + e.touches[1].pageY) / 2;\r\n            var centerClientX = (e.touches[0].locationX + e.touches[1].locationX) / 2;\r\n            var centerClientY = (e.touches[0].locationY + e.touches[1].locationY) / 2;\r\n            var width = Math.abs(e.touches[0].pageX - e.touches[1].pageX);\r\n            var height = Math.abs(e.touches[0].pageY - e.touches[1].pageY);\r\n            var distance = this._calcDistance(width, height);\r\n            var angle = this._calcAngle(e.touches);\r\n            var initialCenterPageX = initializeFromEvent ? centerPageX : p.initialCenterPageX;\r\n            var initialCenterPageY = initializeFromEvent ? centerPageY : p.initialCenterPageY;\r\n            var initialCenterClientX = initializeFromEvent ? centerClientX : p.initialCenterClientX;\r\n            var initialCenterClientY = initializeFromEvent ? centerClientY : p.initialCenterClientY;\r\n            var initialWidth = initializeFromEvent ? width : p.initialWidth;\r\n            var initialHeight = initializeFromEvent ? height : p.initialHeight;\r\n            var initialDistance = initializeFromEvent ? distance : p.initialDistance;\r\n            var initialAngle = initializeFromEvent ? angle : p.initialAngle;\r\n            var velocityX = initializeFromEvent ? 0 : gestureState.vx;\r\n            var velocityY = initializeFromEvent ? 0 : gestureState.vy;\r\n            multiTouchEvent = {\r\n                initialCenterPageX: initialCenterPageX,\r\n                initialCenterPageY: initialCenterPageY,\r\n                initialCenterClientX: initialCenterClientX,\r\n                initialCenterClientY: initialCenterClientY,\r\n                initialWidth: initialWidth,\r\n                initialHeight: initialHeight,\r\n                initialDistance: initialDistance,\r\n                initialAngle: initialAngle,\r\n                centerPageX: centerPageX,\r\n                centerPageY: centerPageY,\r\n                centerClientX: centerClientX,\r\n                centerClientY: centerClientY,\r\n                velocityX: velocityX,\r\n                velocityY: velocityY,\r\n                width: width,\r\n                height: height,\r\n                distance: distance,\r\n                angle: angle,\r\n                isComplete: isComplete,\r\n                timeStamp: e.timeStamp,\r\n                isTouch: !GestureView._isActuallyMouseEvent(e),\r\n            };\r\n        }\r\n        if (this.props.onPinchZoom) {\r\n            this.props.onPinchZoom(multiTouchEvent);\r\n        }\r\n        if (this.props.onRotate) {\r\n            this.props.onRotate(multiTouchEvent);\r\n        }\r\n        return multiTouchEvent;\r\n    };\r\n    GestureView.prototype._touchEventToTapGestureState = function (e) {\r\n        var pageX = e.pageX;\r\n        var pageY = e.pageY;\r\n        var clientX = e.locationX;\r\n        var clientY = e.locationY;\r\n        // Grab the first touch. If the user adds additional touch events,\r\n        // we will ignore them. If we use e.pageX/Y, we will be using the average\r\n        // of the touches, so we'll see a discontinuity.\r\n        if (e.touches && e.touches.length > 0) {\r\n            pageX = e.touches[0].pageX;\r\n            pageY = e.touches[0].pageY;\r\n            clientX = e.touches[0].locationX;\r\n            clientY = e.touches[0].locationY;\r\n        }\r\n        return {\r\n            timeStamp: this._getEventTimestamp(e),\r\n            clientX: clientX,\r\n            clientY: clientY,\r\n            pageX: pageX,\r\n            pageY: pageY,\r\n            isTouch: !GestureView._isActuallyMouseEvent(e),\r\n        };\r\n    };\r\n    GestureView.prototype._mouseEventToTapGestureState = function (e) {\r\n        var xyOffset = this._getClientXYOffset();\r\n        return {\r\n            timeStamp: this._getEventTimestamp(e),\r\n            clientX: e.clientX - xyOffset.x,\r\n            clientY: e.clientY - xyOffset.y,\r\n            pageX: e.pageX || 0,\r\n            pageY: e.pageY || 0,\r\n            isTouch: false,\r\n        };\r\n    };\r\n    GestureView.prototype._getClientXYOffset = function () {\r\n        return { x: 0, y: 0 };\r\n    };\r\n    GestureView.prototype._sendPanEvent = function (e, gestureState, gestureType, initializeFromEvent, isComplete) {\r\n        var state = this._pendingGestureState;\r\n        assert_1.default(this._lastGestureStartEvent, 'Gesture start event must not be null.');\r\n        var initialPageX = this._lastGestureStartEvent\r\n            ? this._lastGestureStartEvent.pageX\r\n            : initializeFromEvent ? e.pageX : state.initialPageX;\r\n        var initialPageY = this._lastGestureStartEvent\r\n            ? this._lastGestureStartEvent.pageY\r\n            : initializeFromEvent ? e.pageY : state.initialPageY;\r\n        var initialClientX = this._lastGestureStartEvent\r\n            ? this._lastGestureStartEvent.locationX\r\n            : initializeFromEvent ? e.clientX : state.initialClientX;\r\n        var initialClientY = this._lastGestureStartEvent\r\n            ? this._lastGestureStartEvent.locationY\r\n            : initializeFromEvent ? e.clientY : state.initialClientY;\r\n        var velocityX = initializeFromEvent ? 0 : gestureState.vx;\r\n        var velocityY = initializeFromEvent ? 0 : gestureState.vy;\r\n        var panEvent = {\r\n            initialPageX: initialPageX,\r\n            initialPageY: initialPageY,\r\n            initialClientX: initialClientX,\r\n            initialClientY: initialClientY,\r\n            pageX: e.pageX,\r\n            pageY: e.pageY,\r\n            clientX: e.clientX,\r\n            clientY: e.clientY,\r\n            velocityX: velocityX,\r\n            velocityY: velocityY,\r\n            isComplete: isComplete,\r\n            timeStamp: e.timeStamp,\r\n            isTouch: !GestureView._isActuallyMouseEvent(this._lastGestureStartEvent),\r\n        };\r\n        switch (gestureType) {\r\n            case GestureType.Pan:\r\n                if (this.props.onPan) {\r\n                    this.props.onPan(panEvent);\r\n                }\r\n                break;\r\n            case GestureType.PanVertical:\r\n                if (this.props.onPanVertical) {\r\n                    this.props.onPanVertical(panEvent);\r\n                }\r\n                break;\r\n            case GestureType.PanHorizontal:\r\n                if (this.props.onPanHorizontal) {\r\n                    this.props.onPanHorizontal(panEvent);\r\n                }\r\n                break;\r\n            default:\r\n            // do nothing;\r\n        }\r\n        return panEvent;\r\n    };\r\n    GestureView._toMouseButton = function (nativeEvent) {\r\n        if (nativeEvent.button !== undefined) {\r\n            return nativeEvent.button;\r\n        }\r\n        else if (nativeEvent.isRightButton || nativeEvent.IsRightButton) {\r\n            return 2;\r\n        }\r\n        else if (nativeEvent.isMiddleButton || nativeEvent.IsMiddleButton) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    };\r\n    GestureView.prototype._sendDoubleTapEvent = function (e) {\r\n        // If user did a double click with different mouse buttons, eg. left (50ms) right\r\n        // both clicks need to be registered as separate events.\r\n        var lastButton = GestureView._toMouseButton(this._lastTapEvent);\r\n        var button = GestureView._toMouseButton(e);\r\n        if (lastButton !== button || button === 2) {\r\n            this._sendTapEvent(this._lastTapEvent);\r\n            return;\r\n        }\r\n        if (this.props.onDoubleTap) {\r\n            this.props.onDoubleTap(e);\r\n        }\r\n        this._lastTapEvent = undefined;\r\n    };\r\n    return GestureView;\r\n}(React.Component));\r\nexports.GestureView = GestureView;\r\nexports.default = GestureView;\r\n"]},"metadata":{},"sourceType":"script"}